<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[lqs469]]></title><description><![CDATA[lqs469 Blog]]></description><link>https://lqs469.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 25 Dec 2020 07:57:00 GMT</lastBuildDate><item><title><![CDATA[NLRealtimeRecords]]></title><link>https://lqs469.github.io/NLRealtimeRecords/</link><guid isPermaLink="false">https://lqs469.github.io/NLRealtimeRecords/</guid><content:encoded></content:encoded></item><item><title><![CDATA[Star]]></title><link>https://lqs469.github.io/Star/</link><guid isPermaLink="false">https://lqs469.github.io/Star/</guid><content:encoded></content:encoded></item><item><title><![CDATA[EuroCup2016]]></title><link>https://lqs469.github.io/WorldCup/</link><guid isPermaLink="false">https://lqs469.github.io/WorldCup/</guid><content:encoded></content:encoded></item><item><title><![CDATA[Xmas hat]]></title><link>https://lqs469.github.io/XmasHat/</link><guid isPermaLink="false">https://lqs469.github.io/XmasHat/</guid><content:encoded></content:encoded></item><item><title><![CDATA[Confluence Export]]></title><link>https://lqs469.github.io/confluence-export/</link><guid isPermaLink="false">https://lqs469.github.io/confluence-export/</guid><content:encoded></content:encoded></item><item><title><![CDATA[micro-serverless]]></title><link>https://lqs469.github.io/micro-serverless/</link><guid isPermaLink="false">https://lqs469.github.io/micro-serverless/</guid><content:encoded></content:encoded></item><item><title><![CDATA[Popstar Game]]></title><link>https://lqs469.github.io/popstar/</link><guid isPermaLink="false">https://lqs469.github.io/popstar/</guid><content:encoded></content:encoded></item><item><title><![CDATA[也许你想要的只是一个静态应用]]></title><description><![CDATA[前言 记得刚开始学习做网站的时候，最先学会写出一个 HTML，再给他加上一些 CSS 样式作为修饰，也许最后再加上一丢丢 Javascript 去辅助出一些效果，duang…]]></description><link>https://lqs469.github.io/也许你想要的只是一个静态应用/</link><guid isPermaLink="false">https://lqs469.github.io/也许你想要的只是一个静态应用/</guid><pubDate>Fri, 10 Apr 2020 20:39:47 GMT</pubDate><content:encoded>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;记得刚开始学习做网站的时候，最先学会写出一个 HTML，再给他加上一些 CSS 样式作为修饰，也许最后再加上一丢丢 Javascript 去辅助出一些效果，duang ～ 一个最最基础的网站就完成了，然后我们把它丢到服务器上托管着，用户就可以访问到了。再此之后，我们又学会了用 Java、Python 做动态网站，学会用更复杂的 Javascript 去开发前端 MVC 应用、前后端分离、RESTful。。。&lt;/p&gt;
&lt;p&gt;然鹅，最近几年静态网站似乎又不可思议的火了起来，类似于 Gatsby.js、Next.js 等带 SSG(Static Site Generator) 功能框架受到了一些人的欢迎，这是科技的退步，还是人心的复古，让我们一起走进今天的话题——也许你想要的只是一个静态网站。&lt;/p&gt;
&lt;p&gt;关于 SSG、JAMstack 究竟是什么，这里就不做赘述了。这里给出一个我认为最简短的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SSG - 生成静态网页的框架，基于你熟知的技术（React，Vue）&lt;/li&gt;
&lt;li&gt;JAMStack - 由 JavaScript, APIs, Markup 构成的网站应用，Markup 这里指预渲染好的静态文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然是预渲染好的，那么带来的问题也很明显，很多人担心静态网站不够“动态”，在业务过于“动态”化的今天，可能无法正常使用，比如业务需要频繁操作数据库，需要频繁用户交互等。而我在实际开发过几个 Gatsby 和 Next 项目之后，得出的结论是 SSG 其实可以做到最大程度的“静态化”，或者说，他可以在很多场景发挥出自己应有的作用，甚至比你想象的还多。也许在未来“静态驱动”型应用会占据前端开发的一片江山甚至有可能成为主流。&lt;/p&gt;
&lt;h2&gt;那么，何为“静态”&lt;/h2&gt;
&lt;p&gt;用传统“静态”网站的概念来形容现代的 Static Site 总觉得有点不太合适，那让我们从新认识一下现代前端技术中的 Static Site：Web 应用以数据装载完成且渲染好的 HTML 文件构成为基础，配合 CSS 和 Javascript 的丰富能力将结果直接呈现给用户，而不是在用户请求时由服务动态生成页面文件。&lt;/p&gt;
&lt;p&gt;举个例子，你可以直接将静态应用放到 CDN 上，当用户请求网站，服务直接将以渲染完成的 HTML 返回，并不需要任何服务端的计算，也不会给服务造成过大的压力，服务的角色只是简单的托管。&lt;/p&gt;
&lt;h2&gt;静态的价值&lt;/h2&gt;
&lt;p&gt;首先我们来看看它的优势。当我们谈论静态应用，静态站点，极致的性能肯定是第一值得认可的地方，原因很好解释，服务端几乎为零的计算量，瞬间返回结果。除此之外，好处还很多：&lt;/p&gt;
&lt;h3&gt;稳定性&lt;/h3&gt;
&lt;p&gt;当你引入一项技术、一个工具，也顺便引入了一份风险，因为无论是数据库还是服务器，都有可能发生故障，更有可能因为流量的激增而堵塞，当服务因压力而挂起，用户只会白屏等待或者访问失败。这对于一个永不宕机的应用来说是灾难的，而从加强服务性能本身入手解决问题，无疑将是巨大的成本，而且真正遇到这种流量海啸的机率却是微乎其微，所以日常就是看着 CPU 使用率不到 1% 而花着冤枉钱。这种现象，我们俗称为“不够弹性”，当然你可以用云端弹性计算，Serverless 等方法来解决问题，但这无疑又增加了复杂度，可能又会带来新的问题。当你夜不能寐，也许会想起，我的服务还好吗。&lt;/p&gt;
&lt;p&gt;但如果使用的是静态应用，问题就不存在了，无论流量如何变化，服务的计算量都是零；无论数据库是否正常工作，页面已经生成了，不会对线上造成任何影响；无论任何时间地点，CDN 边缘计算都可以用最快速度在离客户端最近的距离（用户本地缓存除外）把页面交付给用户。绝对可以让你睡个好觉。&lt;/p&gt;
&lt;h3&gt;SEO&lt;/h3&gt;
&lt;p&gt;相对于客户端渲染的 SPA 应用而言，静态应用天生支持 SEO；比起服务端渲染，无需实时计算生成页面，更直观有效；比起 prerending 方案，更稳定可靠。而且无论什么爬虫，即使技术最原始的爬虫也能保证爬到站点信息，因为静态应用提供的本身就是 HTML，而且每个页面的 SEO 信息都是预先可见的，非常直观且易于管理。&lt;/p&gt;
&lt;h3&gt;性能&lt;/h3&gt;
&lt;p&gt;极致的快，得益于服务的无计算过程，也得益于资源可以非常方便的缓存。如果你把应用放到 nginx 托管，可以使用 nginx 缓存；如果放到 CDN，可以直接缓存在云端边缘。除此之外页面还会缓存在浏览器中，而这一切几乎不用写一行代码就可以做到。或者你也可以再写一点 PWA 来管理浏览器端缓存，一切都会变得更美妙。&lt;/p&gt;
&lt;h2&gt;“动态”的数据源&lt;/h2&gt;
&lt;p&gt;上面的优点看起来还不错，但你一定有了疑问：数据是预取的，内容都已经写死了，如果业务有些许“动态”的数据，这下应用该怎么办？别着急，我们慢慢解释。&lt;/p&gt;
&lt;p&gt;无论数据来源是数据库、CMS、还是文件。我们的应用始终依赖该数据之上，我们将数据源统一抽象为原子数据，以取出某个原子数据为例，在传统的服务端渲染应用中，当用户请求页面，会发生以下事件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发出请求 &lt;code class=&quot;language-text&quot;&gt;/XXX&lt;/code&gt;，服务端接到请求，作出反应&lt;/li&gt;
&lt;li&gt;根据请求信息查询数据库或者 CMS 找到结果&lt;/li&gt;
&lt;li&gt;服务端将找到的数据和 HTML 模版进行字符串计算，最后经过一炷香的时间渲染出新的 HTML 文件&lt;/li&gt;
&lt;li&gt;服务端返回渲染好的 HTML 文件给客户端&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么在静态应用这里的情况呢？其实我们可以有很多种设计，最容易的实现大致是静态生成初始页面，页面带有一些 Loading 态或者用户引导，并且在此之上通过 API 和服务端交换数据，完成页面更新：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发出请求 &lt;code class=&quot;language-text&quot;&gt;/XXX&lt;/code&gt;，服务端接到请求，作出反应&lt;/li&gt;
&lt;li&gt;服务端马上返回初始化 HTML 页面，页面并不包含任何动态数据&lt;/li&gt;
&lt;li&gt;在浏览器解析页面之后，页面进入等待，JS 向服务端发出异步请求&lt;/li&gt;
&lt;li&gt;服务端接到请求，根据请求信息查询数据库或者 CMS 找到结果并返回 JSON&lt;/li&gt;
&lt;li&gt;客户端根据返回的 JSON 更新页面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本质上这样的静态应用跟一个单页应用并没什么很大的区别，在初始页面下发之后，执行同样的客户端渲染逻辑，在性能上也只是比单页应用快了一个首页加载而已。其实也可以理解为这是一个折中方案，一方面加速了首屏渲染速度，另一方面数据能够实时动态获取。&lt;/p&gt;
&lt;p&gt;那么，我们换一个思路，假设我们不考虑折中方案，如果一开始就拿到的是完整预渲染完的页面呢？&lt;/p&gt;
&lt;h3&gt;换个思路&lt;/h3&gt;
&lt;p&gt;我们以往的渲染思路普遍都是前端渲染或者服务端渲染，数据实时计算并通过异步或者同步返回给请求方。如果我们在编译时就把数据准备好呢，将已经与渲染好的 HTML 文件直接返回客户端，这可行吗？首先如果这样做，上面的请求过程将变为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发出请求 &lt;code class=&quot;language-text&quot;&gt;/XXX&lt;/code&gt;，服务端接到请求，作出反应&lt;/li&gt;
&lt;li&gt;服务器立即将完整的 HTML 文件返回给客户端&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;没有数据库查询，没有即时计算，返回一个 web 应用跟返回一个“Hello world”字符串的原理一样。而且因为是纯 HTML 文件，浏览器可以缓存在客户侧，一些运转起来都是极致的快。&lt;/p&gt;
&lt;h3&gt;编译时数据预取&lt;/h3&gt;
&lt;p&gt;上面的场景很美好，但现实很骨感。我们想要完成预渲染就得完成编译时数据预取的工作，而且是“全量”的数据，数据依然来自于 CMS，数据库或者数据文件。当你使用命令 &lt;code class=&quot;language-text&quot;&gt;datsby build&lt;/code&gt; 或者 &lt;code class=&quot;language-text&quot;&gt;next build &amp;amp;&amp;amp; next export&lt;/code&gt; 去生成静态应用时，编译程序将请求所有应用依赖到的数据源，他们可以是 API，可以是连接池，可以是 JSON 文件，然后按你希望的方式拼接进字符串中，然后使用 React 提供的 server-rending 相关方法生成一个个完整的 HTML 文件。&lt;/p&gt;
&lt;p&gt;在 Gatsby 中，社区设计了丰富的插件，用于请求不同类型的数据源，并且互相兼容不同的页面和组件，这里可以瞥一眼：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gatsbyjs.org/packages/gatsby-source-filesystem/?=&quot;&gt;gatsby-source-filesystem&lt;/a&gt; ，从文件系统中读取数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gatsbyjs.org/packages/gatsby-source-graphql/?=gatsby-source-graphql&quot;&gt;gatsby-source-graphql&lt;/a&gt; ，从 GraphQL 中获取数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gatsbyjs.org/packages/gatsby-source-wordpress/?=gatsby-source&quot;&gt;gatsby-source-wordpress&lt;/a&gt; ，从 Wordpress CMS 中通过 REST API 获取数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gatsbyjs.org/packages/gatsby-source-s3-image/?=gatsby-source&quot;&gt;gatsby-source-s3-image&lt;/a&gt;，从 S3 服务中获取图片资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Next.js 中并没有像 Gatsby 这么的插件化，不过也可以在下面生命周期内自由引入：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://nextjs.org/docs/api-reference/data-fetching/getInitialProps&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;getInitialProps&lt;/code&gt;&lt;/a&gt;，在渲染动作发生之前给组件传入 props&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;getStaticProps&lt;/code&gt;&lt;/a&gt;，在生成静态文件之前的给组件传入 props&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nextjs.org/docs/basic-features/data-fetching#getstaticpaths-static-generation&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;getStaticPaths&lt;/code&gt;&lt;/a&gt;，规定静态文件路径和访问规则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上过程都会自动搜集数据，自动执行编译，这样很容易就可以跟 CI/CD 结合，工程化和扩展性都很棒。&lt;/p&gt;
&lt;h3&gt;真的是 所有数据？&lt;/h3&gt;
&lt;p&gt;所有数据都下载一遍，生成静态文件得有多少个，这个想法听起来就有点滑稽，这真的可行吗？如果是一个博客网站还好说，也就是每篇文章生成一个页面；但如果是一个电商网站，是不是要生成所有商品的页面，假设商品数以万计，这不是光生成页面就得半天？如果是一个实时监控的控制台呢…&lt;/p&gt;
&lt;p&gt;而我认为这个问题的答案并不是非黑即白，就是说这一切技术架构都得根据真实的业务和应用规模和类型来合理使用，什么意思呢。博客非常适合静态应用，文档也非常适合静态应用，是因为他们本身数据不会经常变动，这个“经常”的频率是不会每隔十分钟都发生变化，而这个不变的数据间隔跟我们重新编译生成静态文件相比，是远远大于需要构建的时间的。而控制台一类的中后台监控页面呢，首先数据是实时的，秒级别或者分钟级别的变化频率远远小于我们编译做需要的时间，所以选择静态应用是个非常消耗且不满足需求的方案。那么问题就很明显了，如何找到合适变化的度就成为了判断是否选择静态应用方案的关键。&lt;/p&gt;
&lt;p&gt;那么究竟这个变化的阈值该如何掌握呢？让我们深入 SSG 技术的前沿领域，Gatsby 社区一方面努力于&lt;a href=&quot;https://www.gatsbyjs.org/blog/2019-06-12-performance-improvements-for-large-sites/&quot;&gt;构建大型应用的性能提升&lt;/a&gt;，另一方面也正在努力于“增量构建”—— &lt;code class=&quot;language-text&quot;&gt;incremental builds&lt;/code&gt; （&lt;a href=&quot;https://github.com/gatsbyjs/gatsby/issues/9083&quot;&gt;incremental builds?&lt;/a&gt;、&lt;a href=&quot;https://www.gatsbyjs.com/incremental-builds-beta/&quot;&gt;Gatsby Incremental Builds Private beta&lt;/a&gt;），同样 Next.js 也有类似的 RFC &lt;a href=&quot;https://github.com/zeit/next.js/discussions/11552&quot;&gt;RFC: Incremental Static Generation&lt;/a&gt;。增量构建允许我们在每一次构建中只会重新编译发生了改变的那部分页面和组件，而不是全部重来一遍。这会起到多大的作用呢？让我们用上面没有提到的商场来举例。&lt;/p&gt;
&lt;p&gt;假设一个电商网站有一万件商品，需要生成一万个左右的静态页面，这个是各自商品介绍页面，不包括首页，推荐页，用户页面等定制化页面。那么在第一次耗时较长的构建之后（这个过程可能会比你想象的要少，以我个人的经验来说 1000 张页面大概耗时 500ms，根据实际内容而定所以并不一定准确），静态应用放到 CDN 完成上线，以边缘计算的绝对速度优势服务于全世界的用户，用户惊叹与真特么的快。然鹅这时候有个商品的厂家通过 CMS 改变了售价，于是我们需要对某件商品改价，构建机器的钩子接到推送，启动增量编译，将被修改的某个商品页面单独重新编译后生成 HTML 文件，因为有变化页面非常小，这个过程甚至可以瞬间发生并结束，然后就是在 CDN 上更换该单独页面的静态文件，剩下的事情也可以在瞬间发生并完成。而代码的变化也是同理，增量构建，增量更新，增量替换。只要保障需要重新构建的部分在一定规模内，用户体验几乎是跟动态网站是差不多的。&lt;/p&gt;
&lt;p&gt;而在未来，而随着增加构建、构建加速等特性的不断升级，或许这项技术会成为静态应用方案的一个关键突破点，甚至成为改变生态的胜负手。想一想，如果既有静态应用的优点：稳定、极致性能、可扩展、低功耗，又没有不够“动态”的缺点，简直美滋滋！&lt;/p&gt;
&lt;h2&gt;目前仍然存在的限制&lt;/h2&gt;
&lt;p&gt;然鹅，因为编译速度还不够快，所以现阶段静态应用的依旧受限，上面我也表达出了，并不是所有应用都适合静态化。实时控制台类型的应用就不一定适合，但其实他也可以最大程度的“静态化”，除去数据呈现部分，控制台的骨架、Header、首屏、甚至载入态都是可以静态化的，在此之上再加上异步请求的数据去更新页面。也许你觉得这样做的意义并不大，的确如此，但是如果只是为了首屏加载或者 SEO 目的，其实你已经一定程度上达到了，剩下追求用户体验的目标就可以更多放到 REST API （异步请求）的优化上了。&lt;/p&gt;
&lt;p&gt;同理，此类型的应用也可以是 Feed 流类型的应用，比如微博推特，核心内容是不断更新的，甚至用户个性化数据，但是页面骨架不会变，路由不会变，静态应用还是可以发挥作用，加速首屏渲染速度，简化应用模型，一定程度上减少一些服务端压力。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;静态应用以及 SSG 的技术栈给前端生态带来一些新的解决思路，当我们熟悉了要么 SPA，要么 SSR 之后，发现原来还可以这么玩，老瓶装新酒焕发生机，这无疑给我们一阵头脑风暴。但不论怎么变化，客户端交付给用户的东西是不变的，围绕这一点，前端工程师或者端工程师可以发挥的空间还有很多。而这项技术本身，随着增量构建和构建本身的不断优化加速、解放潜力，也许 SSG 在未来会成为一个不错的解决方案，甚至成为主流也说不定。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Node.js VM 不完全指北]]></title><description><![CDATA[前言  是 Node.js 顶级模块之一，你可以直接在 Node.js 中使用  引入， 的功能是可以在 V8 虚拟机的上下文中编译和执行 JavaScript 代码。 The vm module enables compiling and running code within…]]></description><link>https://lqs469.github.io/Node.js VM 不完全指北/</link><guid isPermaLink="false">https://lqs469.github.io/Node.js VM 不完全指北/</guid><pubDate>Thu, 09 Apr 2020 16:27:40 GMT</pubDate><content:encoded>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://nodejs.org/api/vm.html#vm_vm_executing_javascript&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;vm&lt;/code&gt;&lt;/a&gt; 是 Node.js 顶级模块之一，你可以直接在 Node.js 中使用 &lt;code class=&quot;language-text&quot;&gt;require&lt;/code&gt; 引入，&lt;code class=&quot;language-text&quot;&gt;vm&lt;/code&gt; 的功能是可以在 V8 虚拟机的上下文中编译和执行 JavaScript 代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The vm module enables compiling and running code within V8 Virtual Machine contexts.
——来自Node.js文档&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它比 &lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;Function&lt;/code&gt; 更安全，而且同样很简单。&lt;/p&gt;
&lt;h2&gt;入门&lt;/h2&gt;
&lt;p&gt;那么我们可以用它来做什么呢？假设你有一段可执行的js代码，最简单的两种方法让它run起来：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开浏览器 console，回车执行。&lt;/li&gt;
&lt;li&gt;打开一个 terminal，使用 node 来执行它。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种都是手动、主动的执行。如果想把这个过程自动化，把目标代码放入到我的程序里呢？方法也有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Function&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nodejs.org/api/vm.html#vm_vm_executing_javascript&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;vm&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是 eval 和 Function 实现 runtime 的语法最基本实现，vm 我们会在后面详细介绍：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// eval(string)&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;2 + 2&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// expected output: 4&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;2 + 2&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// expected output: 2 + 2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; sum &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;a&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;b&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;return a + b&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// expected output: 8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以用它们实现一个 javascript 的 runtime 来执行目标代码。比如这样一个场景，我的产品是一个 SDK  Playground，我的客户是开发者，它写了一段测试代码想放进我提供的产品里看看运行结果如何，我想要做成一个自动化的服务，那么用上面语法写这样的 JS runtime 是一个不错的选择。&lt;/p&gt;
&lt;p&gt;上面提到了 &lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;Function&lt;/code&gt;，他们语法和功能我们这里不做介绍了，他也能执行目标代码，但是却带来一些问题：首先最大的是安全性，无论如何目标代码不能影响我正常的服务，也就是说，这个执行环节得是一个沙盒环境，而&lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt;显然并不具备这个能力。如果需要一段不信任的代码放任它执行，那么不光服务，整个服务器的文件系统、数据库都暴露了。甚至目标代码会修改&lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt;函数原型，埋入陷阱等等。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt; 的安全性问题我们就不做更多解释了，其实在生产中，我们应该尽量避免使用它（甚至很多lint规则发现它存在都会报错）。总结来说，作为js的一个全局对象，它并没有任何沙盒的设计，这显然是无法在生产中使用的。而 &lt;code class=&quot;language-text&quot;&gt;Funtion&lt;/code&gt; 也有同样的安全问题，他们俩的差异可以查阅 MDN 文档，这里按下不表。&lt;/p&gt;
&lt;h2&gt;进阶&lt;/h2&gt;
&lt;p&gt;那么，既然说到了沙盒属性，vm具备怎么的特性呢？&lt;/p&gt;
&lt;p&gt;首先你可以使用&lt;code class=&quot;language-text&quot;&gt;vm.Script&lt;/code&gt;方法构建一个脚本对象：&lt;code class=&quot;language-text&quot;&gt;new vm.Script(code[, options])&lt;/code&gt;，他的API可以总结为下面三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;script.runInThisContext(opts)&lt;/code&gt; - 在当前作用域中运行脚本，也就是说，脚本可以访问当前脚本的全局变量，而不是局部作用域。&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;script.runInContext(context, opts)&lt;/code&gt; - 在提供的作用域中运行脚本，作用域是某个 &lt;code class=&quot;language-text&quot;&gt;vm.createContext&lt;/code&gt; 的结果。 在 &lt;code class=&quot;language-text&quot;&gt;script.runInContext&lt;/code&gt; 中，您可以提供一个自定义可控sandbox。&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;script.runInNewContext(sandbox, opts)&lt;/code&gt; - 在一个新的 sandbox 的作用域范围内运行脚本。即 &lt;code class=&quot;language-text&quot;&gt;runInNewContext&lt;/code&gt; 会为您自动调用 &lt;code class=&quot;language-text&quot;&gt;vm.createContext&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然也可以直接用&lt;code class=&quot;language-text&quot;&gt;vm&lt;/code&gt;上的方法：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; vm &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;vm&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
vm&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;runInThisContext&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;code&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; opts&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
vm&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;runInNewContext&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;code&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; sandbox&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; opts&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
vm&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;runInContext&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;code&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; context&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; opts&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面可以看出，&lt;code class=&quot;language-text&quot;&gt;vm&lt;/code&gt;始终提供了一个可选的作用域来实现沙盒特性，以此来隔绝沙盒内外的影响。
更多 API 细节查看官网文档：&lt;a href=&quot;https://nodejs.org/api/vm.html#vm_vm_executing_javascript&quot;&gt;https://nodejs.org/api/vm.html#vm&lt;em&gt;vm&lt;/em&gt;executing_javascript&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;性能对比&lt;/h2&gt;
&lt;p&gt;比起其他实现runtime的方案，vm的速度会慢一些，因为他建立了封闭而完整的上下文环境。下面来个小实验：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var code = `
var fn = () =&amp;gt; {}
I = 100; while(I--) { fn(); }
`;

const vm = require(&amp;#39;vm&amp;#39;);
const context = vm.createContext();
const script = new vm.Script(code);

console.time(&amp;#39;vm&amp;#39;);
script.runInContext(context);
console.timeEnd(&amp;#39;vm&amp;#39;);

console.time(&amp;#39;eval&amp;#39;);
eval(code);
console.timeEnd(&amp;#39;eval&amp;#39;);


// Results:
vm: 1.122ms
eval: 0.156ms&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以明显看出，vm比eval还是慢了不少。&lt;/p&gt;
&lt;h2&gt;安全性&lt;/h2&gt;
&lt;p&gt;使用vm的模块会比eval更为安全，因为vm模块运行的脚本完全无权访问外部作用域（或自行设置一个有限的作用域）。 脚本仍在同一进程中运行，因此为了获得最佳安全性。当然你可以给上下文传入一些通用的API方便开发：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;vm.runInNewContext(`
  const util = require(‘util’);
  console.log(util);
`, {
  require: require,
  console: console
});&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此外，另一个开源库vm2针对vm的安全性等方面做了更多的提升，&lt;a href=&quot;https://github.com/patriksimek/vm2&quot;&gt;vm2&lt;/a&gt;。避免了一些运行脚本有可能“逃出”沙盒运行的边缘情况，语法也跟易于上手，很推荐使用。&lt;/p&gt;
&lt;h2&gt;实战 Demo（我能用它来干什么？）&lt;/h2&gt;
&lt;p&gt;前短时间我用 VM + Midway 做了一个自用的 FaaS 服务，跟其他大型 FaaS 服务基本功能一样，你可以在上面运行、开发和管理你的 serverless 函数，而无需考虑构建和部署基础框架，也不用写任何框架相关的代码，只专注于业务。项目地址：&lt;a href=&quot;https://github.com/lqs469/micro-serverless&quot;&gt;lqs469/micro-serverless: A micro serverless service based on Node.js VM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搭建一些简单的个人助理服务，例如天气提示，新闻推送或单纯提醒我不要错过比赛直播。 而这些小需求并没有必要用完整的框架来搭建几个复杂完整的应用程序来解决。 而 serverless 显然很合适。 所以，我做了这个能满足我需求且简易，灵活的 serverless 服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;做一个 Github Trending&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; url &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;https://github-trending-api.now.sh/repositories&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;curl&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;https://github-trending-api.now.sh/repositories&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; dataType&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;json&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    title&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;item&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt; | 👨‍💻&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;item&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;author&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt; | ⭐️&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;item&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;stars&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt; | &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;item&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;language&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    url&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; item&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;url&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    desc&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; item&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;description&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GET &lt;code class=&quot;language-text&quot;&gt;//127.0.0.1:7001/vm/github_trending&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据传入的地理位置查询天气&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以给函数加入参数，方法时通过请求 URL 的 query，然后在函数中通过 &lt;code class=&quot;language-text&quot;&gt;ctx.query&lt;/code&gt; 取到。比下面的例子可以请求：&lt;code class=&quot;language-text&quot;&gt;//127.0.0.1:7001/vm/weather?location=Tokyo&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// weather.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; location &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &apos;New York’ &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;query&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; url &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;http://api.weatherstack.com/current?access_key=95f5ee664befefc1c49fa0dac0da19c7&amp;amp;query=&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;location&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;curl&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;url&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; dataType&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; ‘json’ &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GET &lt;code class=&quot;language-text&quot;&gt;//127.0.0.1:7001/vm/weather?location=Tokyo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;具体实现细节和函数规则可以看&lt;a href=&quot;https://github.com/lqs469/micro-serverless&quot;&gt;Readme&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;Vm 是一个很有用的 API，但是在生产中运用却很少，原因其实也很明显——安全性，没有人愿意开着飞机时引擎暴露给别人，下面总结一下 vm：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;足够实现一些 runtime 场景，让你可以开着飞机修飞机。&lt;/li&gt;
&lt;li&gt;避免了使用极度不安全的 &lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt; 或者 &lt;code class=&quot;language-text&quot;&gt;Function&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;Vm 模块似乎提供了比较安全的实现，以及精心设计的沙盒模型，但是攻击者仍然可以利用它（是的，有兴趣的同学可以查看这篇&lt;a href=&quot;https://pwnisher.gitlab.io/nodejs/sandbox/2019/02/21/sandboxing-nodejs-is-hard.html&quot;&gt;文章&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;Vm2 似乎提供了一个更坚固的沙箱，代码无法“逃脱”，但是安全性问题也可能潜伏其中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总而言之，我仍然认为运行第三方代码的唯一安全方法是“物理地”将应用程序与该代码分离，例如，通过虚拟机、docker、容器中运行它才是让你更放心的方案，至少在生产中采用绝对安全的方案可以让你睡个好觉。但是如果是对于安全要求没有那么高的场景（比如上面的个人服务），vm 不失为一个简单有效的 runtime 方案，基于此可以设计出很多有趣的东西。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[GraphQL 与 REST 相比的优势和短板]]></title><description><![CDATA[GraphQL 是 Facebook 发布的 API 查询语言，自2015年向公众发布以来，一直在改进 Web 和原生应用程序的用户体验。它的“走红”非常迅速，但也有所局限，这篇文章不会介绍他的实现原理和相关概念，而是来看一看它与传统的 REST API…]]></description><link>https://lqs469.github.io/GraphQL与REST相比的优势和短板/</link><guid isPermaLink="false">https://lqs469.github.io/GraphQL与REST相比的优势和短板/</guid><pubDate>Thu, 05 Dec 2019 18:44:06 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://graphql.org/&quot;&gt;GraphQL&lt;/a&gt; 是 Facebook 发布的 API 查询语言，自2015年向公众发布以来，一直在改进 Web 和原生应用程序的用户体验。它的“走红”非常迅速，但也有所局限，这篇文章不会介绍他的实现原理和相关概念，而是来看一看它与传统的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;REST API&lt;/a&gt; 相比，它具有的多种优势和局限。&lt;/p&gt;
&lt;h2&gt;优势1：数据更少&lt;/h2&gt;
&lt;p&gt;这一点很好理解，也是 GraphQL 最大的亮点。在数据请求过程中，用户使用的数据从数据库某处取出，如果您直接使用 SQL 操作数据库，那么您知道只请求所需的几个字段而不是所有字段都拿出来会更有效、更快速，同时造成更少的资源浪费。&lt;/p&gt;
&lt;p&gt;在 REST 请求中，几乎不可能仅仅指定所需的几个字段。结果就是您通常会拿到冗余数据。如果遇到需要一次请求多个数据、查询多个表的情况，那将面临的是指数级增长的麻烦。&lt;/p&gt;
&lt;p&gt;比如一种常见的情况，先请求一个 &lt;code class=&quot;language-text&quot;&gt;userList&lt;/code&gt; 列表，然后在请求每一个 user 的某个字段，比如 &lt;code class=&quot;language-text&quot;&gt;user.name&lt;/code&gt;，一般获取 user 接口设计为获取个人的全部数据，那么对于前端而言，除 name 之外的数据无处可用，造成了浪费。&lt;/p&gt;
&lt;h2&gt;优势2：合并请求&lt;/h2&gt;
&lt;p&gt;GraphQL 的另一个显着优势是能够合并多个请求。举一个 REST 中常见的情况：&lt;/p&gt;
&lt;p&gt;我们需要展示一个小组。我们称之为 &lt;code class=&quot;language-text&quot;&gt;/team_by_id/:team_id&lt;/code&gt;。
该小组有一个用户 ID 列表。我们需要获取每个用户信息，所以为每个 ID 分别调用 &lt;code class=&quot;language-text&quot;&gt;/user/:user_id&lt;/code&gt;, 每个用户调一次。
但是我们还想显示该用户所在的其他小组情况。现在，我们再次调用 &lt;code class=&quot;language-text&quot;&gt;/team_by_user_id/:user_id&lt;/code&gt;，每个团队每个用户调一次。
总计一下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;/team/:id 1 
/user/:id n（n: 小组中的用户数）
/team/:id n×t（t: 每位用户的小组数）&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这是一个由 30 个用户组成的团队，并且每个用户都是 3 个团队，那么我们只获取一次 REST 完整数据需要请求执行 1 + 30 + 30*3 = 121 次。&lt;/p&gt;
&lt;p&gt;当然，您可以找到优化 REST 方法，但是必须手动进行，各种数据缓存来减少请求次数，但是同时也引入了数据缓存和更新的新问题，复杂度维护成本直线提升。&lt;/p&gt;
&lt;p&gt;而它们如果在 GraphQL 中执行。可以按照以下方法将所有这些 REST 请求合并到一个 GraphQL 查询中：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;query TEAM_USERS_DATA {
  team(*id*: $team_id) {
    users {
      userName
      avatar      
      teams {
        teamName
      }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 GraphQL 就可以在单个请求中完成相同的操作。不仅可以提高性能，还仅通过一次调用就完成了原来的递归或循环实现的个不同的查询，降低代码复杂性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查询复杂度的注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于 GraphQL 可以自由地关联模型，并且您可以从另一查询中查询一件事，因此会有“复杂度”的问题，它与 GraphQL 服务器有关。这种复杂度会影响性能。类似于 SQL 查询中的 JOIN 多个表并不会“免费”，GraphQL 解析器也是如此。当我们通过在 GraphQL 中嵌套获取远程模型时，我们称其为“解析”。例如，之前的用户/小组例子中，您可能会注意到，从用户中查询团队或团队中的用户都是快速的。但是，如果您不停地将用户，团队，用户，团队……一遍又一遍地链接在一起，您会发现在某个时间点存在延迟。根据您的特定 GraphQL 服务器，中间件和数据库体系结构，延迟多少以及在什么级别变得明显将有所不同。但是无论您采用何种逻辑设计，最好将查询深度控制在一定水平，减少重复昂贵的查询，同时为您提供应用程序所需的灵活性。&lt;/p&gt;
&lt;p&gt;除此之外，GraphQL 生态本身提供了成熟的缓存中间件，可以让我们快速低门槛的使用 cache，更多详情可以查看 &lt;a href=&quot;https://github.com/graphql/dataloader&quot;&gt;dataloader&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;其实上面 GraphQL 的两个优势就是弥补了 REST 在获取数据中：“过多”（Over-fetching）或“过少”（Under-fetching）的问题，”过多“就会带宽浪费，过少就会重复请求，同样造成浪费。在传统的 REST 请求方式中，即使极为优秀的 API 设计者也无法完美解决这些问题，因此 GraphQL 的思路应运而生。&lt;/p&gt;
&lt;h2&gt;优势3：订阅&lt;/h2&gt;
&lt;p&gt;GraphQL 的另一个好处是“订阅”——进行查询并自动更新的功能。通常，这是使用 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&quot;&gt;WebSockets&lt;/a&gt; 在 GraphQL 服务器端实现的。假设我们要使用 GraphQL 创建一个聊天应用。我们可能会执行以下操作：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;subscription MESSAGES() {
  messagesSubscribe(last: 200) {
    msg    author {
      avatar
      userName
    }
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在应用中，&lt;code class=&quot;language-text&quot;&gt;messagesSubscribe&lt;/code&gt; 将是一系列消息，每次发送新消息时都会自动更新。否则的话，我们就得轮训发送请求，短时间内产生数百个请求。&lt;/p&gt;
&lt;p&gt;对于订阅，打开连接后唯一传输的数据是发送或接收消息的时间。要充分利用订阅，您必须使用支持该订阅的客户端，大多数流行的客户端（例如 &lt;a href=&quot;https://www.apollographql.com/docs/react/&quot;&gt;Apollo Client&lt;/a&gt;）都是内置的。&lt;/p&gt;
&lt;p&gt;有关 GraphQL 订阅可以看这个有趣的示例，Eve Porcello 在 React Rally 2018 上的演讲，其中五名与会者使用 Subscribe 创建了即兴音乐。（视频自带 YouTube 机翻的字幕）&lt;/p&gt;
&lt;div style=&quot;height: 0; padding-bottom: calc(56.25% + 35px); position:relative; width: 100%;&quot;&gt;
  &lt;iframe allow=&quot;autoplay; gyroscope;&quot; allowfullscreen height=&quot;100%&quot; referrerpolicy=&quot;strict-origin&quot; src=&quot;https://www.kapwing.com/e/5de8b6e0b736e20013e89084&quot; style=&quot;border:0; height:100%; left:0; overflow:hidden; position:absolute; top:0; width:100%&quot; title=&quot;Embedded content made with Kapwing&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=F_M8v6MK0Sc&quot;&gt;Eve Porcello - Everything You Need 0to Know About GraphQL in 3 Components - YouTube&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/eveporcello/react-rally&quot;&gt;视频中提及的相关资料可以点这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么，GraphQL 有什么局限吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在前面都在讨论 GraphQL 的优点。 那么与 GraphQL 相比，REST 是否有什么优势呢？公平地说，GraphQL 是在 REST 的基础上构建的，因此其设计是向前的迭代。 REST 一直是现代网络中最有影响力的基础构建块之一，没有它，GraphQL 就不会存在。因此，可以说 GraphQL 在几乎所有方面都比 REST 有了明显的改进。但 GraphQL 也是有其短板：&lt;/p&gt;
&lt;h2&gt;局限1：HTTP 缓存&lt;/h2&gt;
&lt;p&gt;一个非常明显的问题，因为无法使用固定规范的 HTTP 请求，也就无法把数据缓存在 HTTP 层，即使做再多的 GraphQL 服务端缓存，也无法解决网络级别的通信量拥堵问题，目前社区提供了一些客户端级别的缓存方案来解决一部分问题，比如使用 &lt;a href=&quot;https://www.apollographql.com/docs/react/&quot;&gt;Apollo Client&lt;/a&gt; 、&lt;a href=&quot;https://relay.dev/&quot;&gt;Relay&lt;/a&gt;，但是这些当然也不是免费的，需要开发者持续投入精力，增加了不少成本。&lt;/p&gt;
&lt;h2&gt;局限2：HTTP Status&lt;/h2&gt;
&lt;p&gt;正常情况下 GraphQL 只会返回 Status Code &lt;code class=&quot;language-text&quot;&gt;200&lt;/code&gt;，无论当前数据请求是成功或失败，这样传统方法的通讯状态判断和逻辑就无法使用，虽然开发者可以自定义一套错误处理逻辑，但也增加了复杂度。&lt;/p&gt;
&lt;h2&gt;局限3：复杂度陡升&lt;/h2&gt;
&lt;p&gt;面对一个传统有效的解决方案（REST），除非有非做不可的痛点，否则我们一般不会对他下手。在现实中这也体现了出来，GraphQL 虽然已经面世了几年时间，更新迭代几版逐渐趋于稳定状态，但是市场接受度只能说不温不火。一方面 GraphQL 方式涉及了客户端和服务端的传统开发模式，代码入侵较大；另一方面，它对前后端开发人员都有一定的门槛，各种 scheme、query、type、resolver 又增加了复杂度，在情况千差万别的业务场景下，很难说对于整体性能是提升还是下降；同时由于客户端需要有 GraphQL Client 才能使用 API，这也导致 API 的复用和扩展有所受限。&lt;/p&gt;
&lt;h1&gt;结论&lt;/h1&gt;
&lt;p&gt;REST 和 GraphQL 都是基于 HTTP 的数据传输解决方案，GraphQL 可以显著的节省网络传输资源，在带宽紧张的环境中（例如移动端），这将发挥巨大的作用。尽管 GraphQL 相比 REST 有很多显著的优点和升级，但在真实场景中，它并不一定是最适合你的实现。总结来说，如果你希望做的应用追求简单而敏捷，且没有什么特殊考量，那就没什么必要使用 GraphQL，REST 可靠、经济、不易出错；反而言之，如果应用的关键点在于组织复杂数据逻辑，请求存在较多 &lt;code class=&quot;language-text&quot;&gt;Over-fetching&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;Under-fetching&lt;/code&gt; 的情况，或者对于网络环境敏感，那么 GraphQL 会是一发银弹。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Vue.js服务端渲染(SSR)不完全指北]]></title><description><![CDATA[What’s this? SSR(Server-Side Rendering) — 服务端渲染 服务端渲染是相对于客户端渲染而言的(Client Side Render), 它的渲染行为发生在服务器端, 渲染完成之后再将完整页面以HTML…]]></description><link>https://lqs469.github.io/Vue.js服务端渲染(SSR)不完全指北/</link><guid isPermaLink="false">https://lqs469.github.io/Vue.js服务端渲染(SSR)不完全指北/</guid><pubDate>Mon, 30 Sep 2019 14:46:40 GMT</pubDate><content:encoded>&lt;h3&gt;What’s this?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;SSR(Server-Side Rendering) — 服务端渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务端渲染是相对于客户端渲染而言的(Client Side Render), 它的渲染行为发生在服务器端, 渲染完成之后再将完整页面以HTML字符串的形式交给浏览器, 最后经过”注水”&lt;code class=&quot;language-text&quot;&gt;hydrate&lt;/code&gt;过程将一些事件绑定和Vue状态等注入到输出的静态的页面中, 由同步下发给浏览器的的Vue bundle接管状态, 继续处理接下来的交互逻辑. 这也是一种同构应用的实现(代码可以运行在客户端和服务端中).&lt;/p&gt;
&lt;h3&gt;When SSR?&lt;/h3&gt;
&lt;p&gt;那么 &lt;strong&gt;什么情况下该使用SSR方案呢&lt;/strong&gt; , 其实一句话总结下来就是展示型应用:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对SEO有需求. CSR无法直接满足SEO, 他需要切换成SSR或者借助Prerendering方案. Prerendering: 一种在服务端使用无头浏览器渲染出页面, 再输出静态页面的解决方案, 也能实现SEO需求, 好处是比较简单(通过webpack插件就可以实现)可以保持前端模块不需要SSR改造, 但是性能比SSR差不少.&lt;/li&gt;
&lt;li&gt;对首屏渲染速度和性能有需求. 如果需要更早的将页面展现给用户而不是白屏的话, 最好的方案还是把渲染工作交给服务端, CSR(SPA)应用的更适合场景应该是中后台web应用, 一般有较多的交互逻辑和页面数据处理, 同时CSR会使用更多的内存, 对浏览器造成较大的压力.&lt;/li&gt;
&lt;li&gt;过多依赖客户端环境的场景. 直接将渲染工作全部交给客户端和JavaScript来处理其实对于web应用来说是很脆弱的, 浏览器的情况千差万别, 网络环境也是无法预测, 即使做了再多的兼容工作, 也无法保证任何情况下都能完美展示. 有时候即使框架本身也不足以(不愿意)支持所有情况.&lt;/li&gt;
&lt;li&gt;安全性考量. 对于有权限控制和内容限制的应用, 使用SPA的时候就要考虑很多安全性限制的问题, 对于应用结构的设计增加了不少复杂度.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Why SSR ?&lt;/h3&gt;
&lt;p&gt;在早期的web开发技术栈中, 实际上都是服务端渲染, 像是Java, PHP, ROR, ASP.NET. 当前端MVC出现之后, 浏览器端渲染模型开始出现并且流行 — “开局一块HTML模板, 元素全靠JS加载”. 这种方式带来了比较快速的页面切换体验和极好的开发效率, 以及丰富的技术生态.
但是CSR也不是没有缺点, &lt;strong&gt;缺点很明显&lt;/strong&gt;而且不改变其核心思路的话没办法克服:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SEO不友好
首先因为开局服务器丢给浏览器的是一块空白(有标记)的HTML模板和一坨打包好的JS代码, 所以做SEO时候普通的爬虫没办法实抓取到真实的web内容, 虽然现代爬虫号称已经能够处理CSR页面, 但是处理成本过高等问题还是让CSR的SEO结果不尽如人意.&lt;/li&gt;
&lt;li&gt;首屏加载速度
同样因为浏览器会在接受到完整的一坨JS代码之后才能执行他, 导致了首屏加载经历了:
解析HTML(渲染HTML模板) -&gt; 获取JS -&gt; 执行JS -&gt; JS渲染页面 -&gt; JS处理数据相关逻辑 -&gt; 页面加载完成. 这样一个过程之后才能完整呈献给用户, 速度自然就下来了, 更不用说网络因素和客户端环境因素对体验的影响. 即使有前端缓存的存在, 但是页面渲染过程仍然不会轻松.&lt;/li&gt;
&lt;li&gt;鉴权等安全性功能实现起来较复杂
其次, 因为是服务端一股脑把打包好的JS代码交给用户, 所以如果在应用中有鉴权的逻辑, 就会牵扯到鉴权逻辑的设计. 这时候就要前后端合作来保证安全性, 复杂度增加.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实在大多数场景下, 你都没必要使用SPA的方案(可以看看&lt;a href=&quot;https://journal.plausible.io/you-probably-dont-need-a-single-page-app&quot;&gt;这篇文章&lt;/a&gt; ). 那么既然某些场景下不适合使用CSR方案, 我们直接退回到以前的web开发方式就好了, 干嘛要去踩SSR新的坑呢?  那么&lt;strong&gt;对比传统的web应用, 使用框架SSR的好处&lt;/strong&gt;有哪些呢:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对比传统方式, 首先最大的好处当然就是技术栈生态, Vue, React等前端MVC给开发带来很大便利, 相应的生态也蓬勃发展, 配套的UI套件, 框架组件, 设计语言, API设计很多程度上已经改变了如今的开发方式. 换句话说, 使用jQuery纯手撸的人原来越少了.&lt;/li&gt;
&lt;li&gt;其次是同构带来的便利. 一套代码由两边的执行环境使用, 可以同时支持SSR和CSR的渲染, 当SSR失效的时候还可以降级为CSR, 或者当服务器压力过大的时候主动降级以增强鲁棒性.&lt;/li&gt;
&lt;li&gt;对技术人员的技术栈统一. SSR还是使用的前端工程师常规熟悉的技术栈, 没有过大的技术门槛, 也没有太多的技术债, 更适合项目的可持续维护和前端团队的技术发展.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;构建逻辑&lt;/h3&gt;
&lt;p&gt;在Vue-SSR构建过程中, 会将代码打包分成两个部分: 服务端bundle; 客户端bundle.
Node.js会处理服务端bundle用于SSR, 客户端bundle会在用户请求时和已经由SSR渲染出的页面一起返回给用户, 然后在浏览器执行”注水”(&lt;code class=&quot;language-text&quot;&gt;hydrate&lt;/code&gt;), 接管Vue接下来的业务逻辑. 这里就会有一个问题, 服务端是如何将store状态交给客户端的呢, 因为整个构建流程是彼此独立的, 数据预取(在进入渲染页面之前获取到页面所需要的数据)之后交给了store, 而注水过程怎么接收store数据? 其实中间有一个特殊的状态保存: &lt;code class=&quot;language-text&quot;&gt;window.__INITIAL_STATE__&lt;/code&gt;, 这个state会在服务端渲染执行&lt;code class=&quot;language-text&quot;&gt;context.state = store.state;&lt;/code&gt;的时候自动写入&lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt;中, 所以在客户端代码中就就可以直接通过&lt;code class=&quot;language-text&quot;&gt;store.replaceState()&lt;/code&gt;接收服务端预取的数据了.&lt;/p&gt;
&lt;p&gt;构建逻辑示意图很经典, 如下:&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/15d4e944e835243e004ab08e46fa7cd3/99e81/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 45.94594594594595%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABeUlEQVQoz21SyU7DMBDNZ/MHSFw4ceBegeCAhDhw4oBUqRKIsldAW7pSt0mrNE2a1fZjPG66ICayPHZm3vi9GUdrDaUUSiuKAss4gbn/u4xt+1JKjt1kAw6DUUCaZrzMOcvynURzZ8/bgBqykFhES2RRiMyfQVEBBjSVfoQLMZmRv6nnBTHqbZcBNyxsEa8v0H9vsz8+Ocbb/h7icAFHU2ClJtD06U/nCkntCEpbOvMoRdcNWQalJHKpUdAyX0DFvZ5g+Pl9FdO7KiRhEaDE6yBEexjDb70jHb5w1afODG6Qsp8TIJXA+e0IN4+eEWHNwjxI0h4kklk4WpM+ucT1WQOXp01EsaUl/BjLVK4aZfd6o4fPzph9lygPGt/sJ80DpIOKbYoBTJIcH88TjIcBC2v10piShg+tCdO3zVstMl94GH11WZakfYhMXDB9p+zgmsJWd4M4Q8+LdpqiVzGlBYuQNS9z+YW207RLtU4ux2l3bP6fR23nif1fN6S3zbKq9eUAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;SSR构建逻辑.png&quot;
        title=&quot;SSR构建逻辑.png&quot;
        src=&quot;/static/15d4e944e835243e004ab08e46fa7cd3/fcda8/1.png&quot;
        srcset=&quot;/static/15d4e944e835243e004ab08e46fa7cd3/12f09/1.png 148w,
/static/15d4e944e835243e004ab08e46fa7cd3/e4a3f/1.png 295w,
/static/15d4e944e835243e004ab08e46fa7cd3/fcda8/1.png 590w,
/static/15d4e944e835243e004ab08e46fa7cd3/efc66/1.png 885w,
/static/15d4e944e835243e004ab08e46fa7cd3/c83ae/1.png 1180w,
/static/15d4e944e835243e004ab08e46fa7cd3/99e81/1.png 1946w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以webpack需要两个入口(服务端, 客户端):&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;entry-client.js&lt;/strong&gt;:
客户端 entry 只需创建应用程序, 并且将其挂载到DOM, 然后将Store状态同步给客户端bundle：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; createApp &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;../main&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; app&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; store&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; router &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createApp&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 同步store&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;__INITIAL_STATE__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;replaceState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;__INITIAL_STATE__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

router&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;onReady&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	router&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;beforeResolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;to&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; matched &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; router&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getMatchedComponents&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;to&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; prevMatched &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; router&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getMatchedComponents&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; diffed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; activated &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; matched&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; diffed &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;diffed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; prevMatched&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; asyncDataHooks &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; activated&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;asyncData&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; _&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;asyncDataHooks&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    Promise&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;asyncDataHooks&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;hook&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hook&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; store&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; route&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; to &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;client entry asyncData function emit&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

	app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;$mount&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;#app&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;entry-server.js&lt;/strong&gt;:
服务端入口需要处理路由, 并触发数据预取逻辑&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; createApp &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;../main&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;resolve&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; reject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; app&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; router&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; store &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createApp&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    router&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;context&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;url&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

	  router&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;onReady&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; matchedComponents &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; router&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getMatchedComponents&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;token comment&quot;&gt;// 对所有匹配的路由组件调用 `asyncData()`&lt;/span&gt;
      Promise&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
        matchedComponents&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Component&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;asyncData&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; Component&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;asyncData&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; store&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; route&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; router&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;currentRoute &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          context&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;app&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;reject&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; reject&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;具体实现&lt;/h3&gt;
&lt;!-- &gt; VueSSR + Begg 的实现已经集成进了脚手架工具[K2](http://gitlab.alibaba-inc.com/qinshuo.lqs/k2)中.
&gt;
&gt; 感兴趣的同学可以尝试一下, 一键搭建, 即开即用😃 --&gt;
&lt;p&gt;明确了选型原因和框架特性, 我们就要开始着手搭建一个Vue-SSR框架, 推荐文档: 官方出品的SSR指南 &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;https://ssr.vuejs.org/&lt;/a&gt; . 里面讲解了你所需要知道的全部名词解释和API介绍, 基本不需要再单独查资料了. 同时他给出了一个官方出品的 &lt;a href=&quot;https://github.com/vuejs/vue-hackernews-2.0/&quot;&gt;Demo&lt;/a&gt;, demo的作者就是尤雨溪, 你想要参考的内容里面也基本都实现了一遍, 不过这个Demo是基于Express的, 改造成Egg还需要一些工作. &lt;/p&gt;
&lt;p&gt;Vue-SSR + Egg.js, 在结构上跟普通的Vue服务端渲染也是一样的. 首次请求到达时, 由Egg.js处理, 在服务端执行渲染器逻辑并输出静态页面, 一共输出的还有客户端bundle, 然后客户端bundle接管应用, 继续接下来的任务, 变成一个”普通”的Vue应用. 同时Egg.js还会处理来自页面的异步请求, 处理正常服务端的工作. 下面是应用整体结构的示意:&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/c3b984632fc7471948f3d2a54f35bcac/92bb4/2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51.35135135135135%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB70lEQVQoz21SzW7TQBDOI/B+3IEn4AmK1EOpeAAQ4oAqjsAJOFEEKqrKoUnkqDR1FRLspLZjr3e9v/bH7NqJemCk9e56dr75ZuYbdV2HFkBHq65rMCGA4e598Gs4d8PZG6d3SZKgLLe4byNnLdTyD9RqiarmSKIIfDKGmM9hjenBWrsH5mWJdLGAUQqGYhshoRoFrU1IOGqdQ372A/n3byEg//IZ2YvnyF+/Akv+Bvbe/K4JYHF8hN9PHpH/JepK4uriBle/YrCcE2BLDAlQ3MZYjy8pwECtE8hZBD2/hhQNLKeSLt/Dlim4cdhQouLwGcq3b8BZg/T2DmXGAkuPNfLZjXXIigLadHs2/kSFQow/oXv6APzsBHJoYcMl8rSiVUKrvi1t28JSBYGhDv2gptcRMZmS0/fNQWkLUxfA5CMc20AQC2MU7lY5Zuc3iMdL5JstxZrQ4sDQf5wvlRLx2RFWXx+CFTQgJsB5Deva/QT9W09dc4t8XdBAGop1kFIGn2c58jSds71s4ndg0wPIOglsvAJ8as92J5lSZlgU11C2CXdDSmCMBbAgm6BDuvgJFdstGElnp7vdox2Y6yxOJsc4PH2MKDsP/xJSQhzHqKqqB8R/7L6A94LuerlPNz9xGn9A3qTBr7WCIJGbQbP/AFZg+ZmFXsuzAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;SSR应用整体结构.png&quot;
        title=&quot;SSR应用整体结构.png&quot;
        src=&quot;/static/c3b984632fc7471948f3d2a54f35bcac/fcda8/2.png&quot;
        srcset=&quot;/static/c3b984632fc7471948f3d2a54f35bcac/12f09/2.png 148w,
/static/c3b984632fc7471948f3d2a54f35bcac/e4a3f/2.png 295w,
/static/c3b984632fc7471948f3d2a54f35bcac/fcda8/2.png 590w,
/static/c3b984632fc7471948f3d2a54f35bcac/efc66/2.png 885w,
/static/c3b984632fc7471948f3d2a54f35bcac/c83ae/2.png 1180w,
/static/c3b984632fc7471948f3d2a54f35bcac/92bb4/2.png 1824w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;具体来说, SSR的核心思路就是使用&lt;code class=&quot;language-text&quot;&gt;vue-server-renderer&lt;/code&gt;创建一个渲染器(renderer), 然后给这个渲染器传入Vue实例, 渲染器会得到HTML页面, 最后由Egg.js将HTML返回, 实现代码有些繁杂这里就不一一放出来了, 核心流程可以简化成:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 第 1 步：创建一个 Vue 实例&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; app &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Vue&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; template&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&amp;lt;div&gt;Hello World&amp;lt;/div&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 第 2 步：创建一个 renderer&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; renderer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;vue-server-renderer&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createRenderer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 第 3 步：将 Vue 实例渲染为 HTML&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; html &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; renderer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;renderToString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;app&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 第 4 步, 返回 HTML&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;body &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;renderString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;html&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体的实现代码可以在k2搭建的SSR框架中的&lt;code class=&quot;language-text&quot;&gt;app/controller/template.js&lt;/code&gt;文件中找到.&lt;/p&gt;
&lt;h3&gt;开发环境&lt;/h3&gt;
&lt;p&gt;SSR + Egg 的生产实现并不难, 但是支持HMR的开发环境搭建就稍麻烦些, 主要是&lt;code class=&quot;language-text&quot;&gt;devMiddleware&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;hotMiddleware&lt;/code&gt;和Egg.js配合使用. 原理是使用这些开发中间件监听并构建Vue文件后放在内存中, 再响应用户的请求.&lt;/p&gt;
&lt;p&gt;具体来说, 在开发环境下, dev renderer中会执行dev-server并监听Vue代码, 当Vue代码发生变化时更新渲染renderer, 并返回给Egg, Egg会等待dev-server的返回后去执行输出. 因为egg的是基于koa, 所以dev Middleware简单封装一下直接挂载egg中的app上就可以, 具体实现代码可以查看k2搭建的SSR框架中的&lt;code class=&quot;language-text&quot;&gt;build/setup-dev-server.js&lt;/code&gt;文件.&lt;/p&gt;
&lt;p&gt;这里有个值得注意的地方就是&lt;code class=&quot;language-text&quot;&gt;hotMiddleware&lt;/code&gt;中间键在注册之后就会接管所有请求, 这时候本希望走到Egg的请求就会被指向Vue,  这是不希望看到的, 所以需要在&lt;code class=&quot;language-text&quot;&gt;hotMiddleware&lt;/code&gt;中过滤一下:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// setup-dev-server.js&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hotFn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;ctx&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 过滤 HMR&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;url&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;indexOf&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;webpack_hmr&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; stream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PassThrough&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;body &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; stream&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hotMiddleware&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;req&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token function-variable function&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      write&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; stream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;stream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token function-variable function&quot;&gt;writeHead&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; headers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;headers&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;hotMiddleware headers&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; headers&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    next
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hotFn&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;SSR优化&lt;/h3&gt;
&lt;p&gt;通过服务端渲染, 我们将应用从IO密集型转为了CPU密集型, CPU的压力会在QPS爆发时剧增, 这时候就需要针对SSR进行一些优化, 常见的优化方式有:&lt;/p&gt;
&lt;h4&gt;缓存&lt;/h4&gt;
&lt;p&gt;一般分为页面级别缓存和组件级别缓存.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;页面级别缓存: 对于相同的页面的请求, 其内容也相同(不考虑个性化页面情况), 所以将路由与对应页面缓存下来可以很有效命中缓存, 降低性能开销.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 使用 LRU &lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; microCache &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;LRU&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  max&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  maxAge&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 重要提示：条目在 1 秒后过期。&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 命中缓存&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hit &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; microCache&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;req&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;url&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hit&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hit&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 缓存下来&lt;/span&gt;
microCache&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;req&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;url&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; html&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组件级别缓存: 组件缓存在组件渲染过程进行命中判断, 所以会影响组件渲染结果, 所以要确保组件不依赖上下文状态且无副作用, 换句话说缓存的是不会改变内容的展示型组件. 实现方法是使用&lt;code class=&quot;language-text&quot;&gt;vue-server-renderer&lt;/code&gt;内置的组件级别缓存配置参数, 在创建 renderer 时传入. 更多参数可以参考 &lt;a href=&quot;https://ssr.vuejs.org/zh/api/#cache&quot;&gt;具体缓存实现方式&lt;/a&gt; .&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; renderer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createRenderer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  cache&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;LRU&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    max&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    maxAge&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;降级方案&lt;/h4&gt;
&lt;p&gt;核心思路就是当CPU使用率过高的时候即使切换到CSR模式.
可以结合Egg提供的schedule能力, 在启动时执行一个定时任务, 监控CPU使用率, 当大于阈值时切换到CSR模式. 而Egg也提供了单核schedule能力, 这样可以将定时任务的性能损耗降到很小; 或者在渲染执行时计时, 如果超时则自动返回CSR bundle, 降级为CSR应用, 这样虽然能临时解决CPU高开销无法及时响应的问题, 但用户体验并没有什么实质性改良.&lt;/p&gt;
&lt;h3&gt;要注意的坑&lt;/h3&gt;
&lt;p&gt;Vue-SSR的坑还是不少的, 特别是和Egg.js结合时, 经过了一段比较蛋疼的踩坑阶段,  现在终于稳定下来支撑业务. 这里把开发期间&lt;strong&gt;遇到的问题&lt;/strong&gt;总结一下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生命周期不同. 这个问题最为明显, 在CSR和SSR中生命周期钩子是不同的. SSR中只有&lt;code class=&quot;language-text&quot;&gt;beforeCreate&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;created&lt;/code&gt;会被执行. 而在CSR中所有周期都会再执行一遍. 另外需要注意的是, 在服务端代码中不要写有全局副作用的代码, 例如写了 &lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt;而不清除它. 因为在SSR周期没有&lt;code class=&quot;language-text&quot;&gt;beforeDestory&lt;/code&gt;阶段, 所以以往CSR中销毁页面前清除副作用的方法就没法继续使用了, 而此时的&lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt;就会被永远不会清除了!&lt;/li&gt;
&lt;li&gt;因为我们采用同构的目的是写一份尽量通用的代码, 让它运行在两端. 所以我们需要对不同端的运行环境特别熟悉才行, Node.js端是没有浏览器对象的, 所以&lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;document&lt;/code&gt;, DOM操作都没法执行. 同理, 浏览器端是没有&lt;code class=&quot;language-text&quot;&gt;process&lt;/code&gt;对象的. 他们各自的API实现也有差别, 这点需要特别留意. 比较麻烦的就是第三方库的引入, 有时候你并不知道引入的库能不能完全运行在Node端/浏览器端. 如果它只能运行在纯浏览器环境, 那可以在&lt;code class=&quot;language-text&quot;&gt;created&lt;/code&gt;阶段之后引入和执行来避开Node.js下执行.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免单例. 在CSR中, 每次我们打开页面都是从服务端下载代码(或缓存), 然后创建一个全局的根Vue实例. 但在SSR中情况有所变化, 因为服务端会一直运行, 如果一直用同一个全局的Vue实例, 就会导致每次客户端的请求到指向了同一个根Vue实例, 就有可能造成状态污染. 所以这里要使用工厂函数在每次请求到来时, 新建一个Vue实例, 执行逻辑返回结果. 同样的, &lt;code class=&quot;language-text&quot;&gt;Store&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;Router&lt;/code&gt;也要这样处理:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// main.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Vue &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;vue&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; App &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./App.vue&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; createStore &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./store&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; createRouter &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./router&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createApp&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; store &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createStore&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; router &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createRouter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; app &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Vue&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    router&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    store&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    render&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;h&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;App&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; app&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; router&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; store &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// router.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Vue &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;vue&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Router &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;vue-router&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Home &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./views/Home&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; About &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./views/About&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

Vue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Router&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createRouter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Router&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    mode&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;history&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    routes&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        path&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;/&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        component&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Home&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        path&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;/about&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        component&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; About&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据预取问题. 在业务中经常会遇到需要我们输出的页面是带有动态数据的, 也就是在渲染页面的时候先异步取一次数据, 然后将返回的数据放入页面中, 最后输出给用户. 其实处理这个逻辑的原理很简单, 就是在服务端整个请求周期中预取数据再注入最后页面就行. 为了尽早的发出请求, 可以在路由模块中执行数据预取逻辑, 在实例化之前就执行异步请求, 然后放入&lt;code class=&quot;language-text&quot;&gt;Vuex&lt;/code&gt;, 然后交给Vue页面去渲染. 这块的代码比较分散, 可以&lt;a href=&quot;https://ssr.vuejs.org/zh/guide/data.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%95%B0%E6%8D%AE%E9%A2%84%E5%8F%96-server-data-fetching&quot;&gt;看这里的实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是使用&lt;code class=&quot;language-text&quot;&gt;v-html&lt;/code&gt;注入动态获取的HTML内容的时候. 如果HTML内容有&lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;所包含的JS代码, 会发现&lt;code class=&quot;language-text&quot;&gt;script&lt;/code&gt;中的事件绑定失效. 其实在这里页面被渲染了两次, 第一次是发生在SSR直接交给浏览器的时候: 此时&lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;完整被渲染在浏览器里, 其内容正常执行, 事件绑定也正常的绑定在了当时的DOM元素上. 而第二次渲染时, 走的是CSR: 在这时由于是以&lt;code class=&quot;language-text&quot;&gt;v-html&lt;/code&gt;的方式来渲染替换HTML, 但是&lt;code class=&quot;language-text&quot;&gt;v-html&lt;/code&gt;实质上是&lt;code class=&quot;language-text&quot;&gt;innerHTML&lt;/code&gt;操作, 这样	&lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;虽然会被替换上去, 但是其中的内容不会执行(&lt;code class=&quot;language-text&quot;&gt;innerHTML&lt;/code&gt;为安全性考虑而设计). 所以经过这样两次渲染之后, 此时的DOM元素是第二次渲染时得到的, 而正常执行过的JS的事件绑定是绑在在第一次渲染出来的DOM元素上, 这样就出现了虽然DOM存在. 但是无法触发该DOM上的事件的情况.&lt;/p&gt;
&lt;p&gt;解决方法:
将获取到的HTML内容进行匹配, 剔出&lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;内容, 无论第一次或第二次渲染, 只将&lt;HTML&gt;内容交给&lt;code class=&quot;language-text&quot;&gt;v-html&lt;/code&gt;页面, 然后单独在生命周期&lt;code class=&quot;language-text&quot;&gt;updated&lt;/code&gt;(页面已将HTML内容渲染完成)中将&lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;创建出来, 添加到页面里自动执行, 实现绑定.
并在下一次页面重渲染(可能是页面跳转来到)时判断&lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;是否存在, 如果真则先删去再添加, 这样避免添加多余的&lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;块.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而页面为什么会渲染两次呢?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是由于Vue SSR在初始页面渲染完成后会有一次&lt;code class=&quot;language-text&quot;&gt;hydration&lt;/code&gt;过程, 在这个过程中会照常执行流程&lt;code class=&quot;language-text&quot;&gt;mounted&lt;/code&gt;等生命周期. 此时会有一个自动判定, 判定是否此时的组件渲染出的内容与SSR渲染得到的内容一致, 如果出现不一致就会单独执行一次额外的CSR, 以达到页面被能正确地渲染. 而因为我们使用了&lt;code class=&quot;language-text&quot;&gt;v-html&lt;/code&gt;, 这个过程只有在CSR时才会被执行, 所以导致了两次渲染出来的内容不一致, 触发了Vue SSR的”补偿渲染机制”, 进而执行了第二次渲染.
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/13c8b72d11b89ed2f3a099661be397a6/d9b5d/3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 10.81081081081081%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAcElEQVQI1y2NSw7CMAwFe/+b0ebTpKEraIQoUlddIRALewoOi9GznuxxJ0tFTg5xEc0FGQLSezTmL6n1ZUZDakznRiq8feTZO14uWH62jY77akJbHrPJZIh2oNNsDyz92ETrA6039FrRy4L8+c3sOwfXDJGwdRcFIwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;image.png&quot;
        title=&quot;image.png&quot;
        src=&quot;/static/13c8b72d11b89ed2f3a099661be397a6/fcda8/3.png&quot;
        srcset=&quot;/static/13c8b72d11b89ed2f3a099661be397a6/12f09/3.png 148w,
/static/13c8b72d11b89ed2f3a099661be397a6/e4a3f/3.png 295w,
/static/13c8b72d11b89ed2f3a099661be397a6/fcda8/3.png 590w,
/static/13c8b72d11b89ed2f3a099661be397a6/efc66/3.png 885w,
/static/13c8b72d11b89ed2f3a099661be397a6/c83ae/3.png 1180w,
/static/13c8b72d11b89ed2f3a099661be397a6/d9b5d/3.png 1224w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cookie传递. 用户的请求会先在服务端被处理, 此时会带客户端的cookie, 但如果在服务端中Egg.js发出异步请求, 这个异步请求中并不带客户端的cookie, 所以如果异步请求需要带携带用户信息的cookie, 此时需要将上下文中的cookie加入Egg的异步请求headers中. 同时返回给客户端时如果涉及到有关cookie的操作也要同步处理一下, 例如用户注销: &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;curl&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;/logout&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  method&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;POST&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  dataType&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;json&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  headers&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 传递 cookie&lt;/span&gt;
    cookie&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;header&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;cookie&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 处理客户端 cookie&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;cookies&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;passport_login&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    domain&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;.XXX.com&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;在实现一个展示型web应用, 或者对首屏性能要求较高的场景(例如官网, 技术文档). SSR都是一个很有效且值得投入的技术方案, 一方面享受了框架带来的便利和生态福利, 一方面也兼顾了性能和可扩展性, 对团队的横向探索和技术栈统一也很有好处. 得益于Vue(或React)和Egg.js生态的优势, 丰富的第三方库和繁荣生态支持, 让开发者有更多的选择和优化空间. 同时开发效率也更适合现代web应用的开发节奏, 不需要很高的技术门槛,  就可以上手开发并且支撑大部分的业务场景. 同时Egg.js框架的成熟也让服务端的能力更为强大, 对于安全性和稳定性的设计让我们在处理复杂场景中更加得心应手.&lt;/p&gt;
&lt;p&gt;当然SSR中的坑也不少, 主要是服务端环境下的API规则的不同和一些数据和逻辑处理的约定(例如生命周期, 环境变量, 数据预取), 但只要注意规避这些问题, 在SSR的开发中还是比较顺滑的. 以目前的API设计来说, SPA的代码无法直接放到服务端就能跑(除非实现CSR应用时就考虑了SSR), 其中想改造的话成本可能还不小. 但是一个新应用想要设计为SSR方案, 基本上开发与维护成本和一个SPA应用差不多, 所以在业务开发中是一个较为可靠的技术方案.&lt;/p&gt;
&lt;!-- 目前我们实现的[k2](http://gitlab.alibaba-inc.com/qinshuo.lqs/k2)脚手架已经集成了 Begg + Vue SSR 解决方案, 一键部署, 即开即用, 欢迎大家尝试. --&gt;</content:encoded></item><item><title><![CDATA[Gitlab API不完全指北]]></title><description><![CDATA[前段时间为手上的项目做了一个自动化构建平台, 需求大致就是实现从 gitlab 中拿到新的代码, 并且也会对分支做一些增删改查的操作, 基本实现方法当然就是一系列 gitlab 开放的 API 能力. 本文会整理出来以方便大家学习使用. Docs Gitlab…]]></description><link>https://lqs469.github.io/Gitlab API 指北/</link><guid isPermaLink="false">https://lqs469.github.io/Gitlab API 指北/</guid><pubDate>Tue, 20 Aug 2019 04:51:01 GMT</pubDate><content:encoded>&lt;p&gt;前段时间为手上的项目做了一个自动化构建平台, 需求大致就是实现从 gitlab 中拿到新的代码, 并且也会对分支做一些增删改查的操作, 基本实现方法当然就是一系列 gitlab 开放的 API 能力. 本文会整理出来以方便大家学习使用.&lt;/p&gt;
&lt;h2&gt;Docs&lt;/h2&gt;
&lt;p&gt;Gitlab 的接入文档写的还是很完善的, 基本上你全都看下来也花不了半天时间. Gitlab文档 &lt;a href=&quot;https://gitlab.com/help/api/README.md&quot;&gt;https://gitlab.com/help/api/README.md&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;TL;TR&lt;/h2&gt;
&lt;p&gt;当然, 你可以选择跳过上面的文档, 这也是写这篇文章的目的. 你只需要了解两件事:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有 API 都需要权限, 需要在 &lt;code class=&quot;language-text&quot;&gt;URL&lt;/code&gt; 或&lt;code class=&quot;language-text&quot;&gt;header&lt;/code&gt;中加一个&lt;code class=&quot;language-text&quot;&gt;private_token&lt;/code&gt;字段. 你可以在个人资料里找到这个&lt;code class=&quot;language-text&quot;&gt;private_token&lt;/code&gt;值.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求URL格式为&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;GET http://example.com/api/v3/projects?private_token&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;QVy1PB7sTxfy4pqfZM1U&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;curl&lt;/span&gt; --header &lt;span class=&quot;token string&quot;&gt;&quot;PRIVATE-TOKEN: QVy1PB7sTxfy4pqfZM1U&quot;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;http://example.com/api/v3/projects&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;阿里的 gitlab API 是 v3 版本. 也就是URL得是: &lt;code class=&quot;language-text&quot;&gt;/api/v3/__&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后就可以想要使用什么API就在上面的文档里查什么就行了. 比如查询用户的所有项目列表:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;GET /projects&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个API支持以下参数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;archived&lt;/code&gt;(optional) - 选填, 是否归档的项目&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;order_by&lt;/code&gt;(optional) - 选填, 排序由 &lt;code class=&quot;language-text&quot;&gt;id&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;created_at&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;updated_at&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;last_activity_atfields&lt;/code&gt;. 默认&lt;code class=&quot;language-text&quot;&gt;created_at&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;sort&lt;/code&gt;(optional) - 选填, 正序&lt;code class=&quot;language-text&quot;&gt;asc&lt;/code&gt;或者倒序&lt;code class=&quot;language-text&quot;&gt;desc&lt;/code&gt;. 默认倒序&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;search&lt;/code&gt;(optional) - 根据搜索字段过滤列表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回结果:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;description&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token null keyword&quot;&gt;null&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;default_branch&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;master&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;public&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;visibility_level&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;ssh_url_to_repo&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;git@example.com:diaspora/diaspora-client.git&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;http_url_to_repo&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;http://example.com/diaspora/diaspora-client.git&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;web_url&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;http://example.com/diaspora/diaspora-client&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;tag_list&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;example&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;disapora client&quot;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;owner&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Diaspora&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;created_at&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2013-09-30T13: 46: 02Z&quot;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Diaspora Client&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;name_with_namespace&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Diaspora / Diaspora Client&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;path&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;diaspora-client&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;path_with_namespace&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;diaspora/diaspora-client&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;issues_enabled&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;open_issues_count&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;merge_requests_enabled&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;builds_enabled&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;wiki_enabled&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;snippets_enabled&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;created_at&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2013-09-30T13: 46: 02Z&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;last_activity_at&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2013-09-30T13: 46: 02Z&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;creator_id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;namespace&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;created_at&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2013-09-30T13: 46: 02Z&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;description&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Diaspora&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;owner_id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;path&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;diaspora&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;updated_at&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2013-09-30T13: 46: 02Z&quot;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;archived&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;avatar_url&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;http://example.com/uploads/project/avatar/4/uploads/avatar.png&quot;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;description&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token null keyword&quot;&gt;null&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;default_branch&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;master&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;public&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;visibility_level&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;ssh_url_to_repo&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;git@example.com:brightbox/puppet.git&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;http_url_to_repo&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;http://example.com/brightbox/puppet.git&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;web_url&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;http://example.com/brightbox/puppet&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;tag_list&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;example&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;puppet&quot;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;owner&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Brightbox&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;created_at&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2013-09-30T13:46:02Z&quot;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Puppet&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;name_with_namespace&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Brightbox / Puppet&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;path&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;puppet&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;path_with_namespace&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;brightbox/puppet&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;issues_enabled&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;open_issues_count&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;merge_requests_enabled&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;builds_enabled&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;wiki_enabled&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;snippets_enabled&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;created_at&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2013-09-30T13:46:02Z&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;last_activity_at&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2013-09-30T13:46:02Z&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;creator_id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;namespace&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;created_at&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2013-09-30T13:46:02Z&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;description&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Brightbox&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;owner_id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;path&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;brightbox&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;updated_at&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2013-09-30T13:46:02Z&quot;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;archived&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;**&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;avatar_url&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; **&lt;span class=&quot;token null keyword&quot;&gt;null&lt;/span&gt;**
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;APIs&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gitlab.com/help/api/api_resources.md&quot;&gt;APIs 文档&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;第三方封装&lt;/h2&gt;
&lt;h3&gt;node-gitlab&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jdalrymple/node-gitlab&quot;&gt;https://github.com/jdalrymple/node-gitlab&lt;/a&gt;
一个个写这些API请求是件很无聊的事, 所以也推荐直接使用封装好的库.&lt;/p&gt;
&lt;p&gt;使用方法基本一目了然:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; Gitlab &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;gitlab&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; api &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Gitlab&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  host&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;http://gitlab.alibaba-inc.com&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  token&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;XXXXXXX&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  version&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;v3&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

api&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;GroupProjects&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;groupId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;友情提示:
node-gitlab 的文档少得可怜, 可能作者觉得官方文档已经足够了, 建议直接看&lt;code class=&quot;language-text&quot;&gt;/src/services&lt;/code&gt;下的源码, 找同名的方法即可.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[10x工程师]]></title><description><![CDATA[硅谷里提到了一个很有趣的概念， 叫做“10x工程师”。Big Head 形容 Richard 的时候说到： “Richard is a 10xer. I’m barely a 1xer.” — Big Head, HBO’s Silicon Valley Silicon…]]></description><link>https://lqs469.github.io/10x工程师/</link><guid isPermaLink="false">https://lqs469.github.io/10x工程师/</guid><pubDate>Sun, 14 Jul 2019 00:36:41 GMT</pubDate><content:encoded>&lt;p&gt;硅谷里提到了一个很有趣的概念， 叫做“10x工程师”。Big Head 形容 Richard 的时候说到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Richard is a 10xer. I’m barely a 1xer.”&lt;/p&gt;
&lt;p&gt;— Big Head, HBO’s Silicon Valley&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Silicon Valley Dictionary 给出的解释是这样：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A concept sometimes used in Silicon Valley to describe an engineer that is 10x more productive than an average engineer although the 10x metric is figurative. Sometimes referred to as “Ninjas”, these engineers are highly sought after by all tech companies.&lt;/p&gt;
&lt;p&gt;（有时在硅谷使用概念来描述的工程师比普通工程师的工作效率高10倍，尽管10x指标是具象的。这些工程师有时被称为“Ninjas”，受到所有科技公司的高度追捧。）&lt;/p&gt;
&lt;p&gt;— 来自&lt;a href=&quot;http://svdictionary.com/words/10x-engineer&quot;&gt;Silicon Valley Dictionary&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在twitter看到一个10x工程师的特点， 分享一下：
来自&lt;a href=&quot;https://twitter.com/skirani/status/1149302828420067328&quot;&gt;Shekhar Kirani&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;10x工程师讨厌会议。他们认为这是浪费时间，而且讨论的都是很明显的事情。他们参加会议是因为经理的要求而召开的“员工会议”，以讨论一些feature和status。&lt;/li&gt;
&lt;li&gt;10x工程师办公室的时间安排非常不规律。他们往往当周围很少有人在他们身边的时候工作。如果有人群或全员会议，则不可见。他们大多数是深夜编码员。&lt;/li&gt;
&lt;li&gt;10x工程师笔记本电脑屏幕背景颜色通常是黑色（它们总是更改默认值）。他们的键盘键如i，f，x通常比a，s和e（电子邮件发件人）都要破旧。&lt;/li&gt;
&lt;li&gt;10x工程师了解已投入生产的每一行代码。如果QA或支持人员提出问题，他们确切地知道故障（或错误）的位置，并且可以在几小时内修复别人需要天级别的任务量。&lt;/li&gt;
&lt;li&gt;大多数10x工程师都是全栈工程师。对于他们来说，代码是代码，他们不关心它是前端，后端，API，数据库，无服务器等。我很少看到他们做UI工作。&lt;/li&gt;
&lt;li&gt;10x工程师可以在他们的脑海中将“思想”转换为“代码”，并一口气将他们编写完成。给出产品功能的具体要求，他们可以用一杯含咖啡因的饮料在4到6个小时的一到两个座位内写下整个功能而不会分心。&lt;/li&gt;
&lt;li&gt;10x工程师很少查看类或方法的帮助文档。他们在记忆中知道它并且可以从记忆中回忆起来。他们编写代码与编写英文一样简单。没有休息，没有暂停，只是输入。&lt;/li&gt;
&lt;li&gt;10倍的工程师总是在公司的每个人之前学习新的框架，语言。他们不怕任何新事物。如果有新的东西（例如区块链），他们会在任何人开始之前吞噬，配置，实验。&lt;/li&gt;
&lt;li&gt;10x工程师是糟糕的导师，因为他们不能很好的教会别人如何去做或者如何包装处理。他们总是认为“教导或与他人讨论需要太长时间，我宁愿自己做。”他们也是不好的面试官。&lt;/li&gt;
&lt;li&gt;10x工程师不是hack东西。他们编写高质量代码并确切知道代码的演变方式，并在心里拥有整体代码结构的设计模型。他们最多写一个设计文档，其余的都在代码中。&lt;/li&gt;
&lt;li&gt;10x工程师很少找工作或离开公司。他们离开是因为你通过会议，培训和其他这类没有增加价值的活动使他们的生活变得不愉快。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这中间有的内容的确比较主观且绝对，并不完全同意他的看法，但说的还蛮有趣的。&lt;/p&gt;
&lt;p&gt;大家都想成为10x工程师，因为能体现自身价值且报酬丰厚。初创公司的雇主当然会更喜欢10x工程师，毕竟低成本还大大提效，而大公司可能就不太一样，大团队中如果全是“superstar”类型的程序员，且不说这现不现实，在各个环节的沟通合作，指责互补等方面来讲不一定有强弱搭配来的有效，而且还带来了一定的管理风险。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[学习的意义]]></title><description><![CDATA[我现在回想起我的大学学到的东西, 发现这是一段我人生最浪费时间的阶段, 整个…]]></description><link>https://lqs469.github.io/学习的意义/</link><guid isPermaLink="false">https://lqs469.github.io/学习的意义/</guid><pubDate>Tue, 10 Jul 2018 14:26:26 GMT</pubDate><content:encoded>&lt;p&gt;我现在回想起我的大学学到的东西, 发现这是一段我人生最浪费时间的阶段, 整个4年都处在无聊, 故作忙碌, 迷茫困惑中度过的, 在那个本该最有冲劲和热情的时间里, 我基本不知道方向在哪里, 目标是什么. 只是跟着密集的课程, 学校的安排去学一些我根本不喜欢或者早就学会的东西, 我没有哪门课获得过100分或者95分, 哪怕是我早就会的内容, 但是我依然在某些感兴趣的科目可以自学不复习就到达90分, 当时只是觉得一点点茫然或者无所谓, 现在我才幡然醒悟, 我特么就是在浪费时间.&lt;/p&gt;
&lt;p&gt;等到我真正走上社会, 开始面对真实世界的考验的时候, 我才发现我什么都不会, 之前的我是被隔离的. 我说的走上社会的真实世界, 并不是指什么校招, 什么笔试, 那些会考大学书本, 考你绩点里要求的东西. 我说的是当你跟全世界竞争, 跟比你年纪大或比你有经验的同行或非同行竞争的时候, 那些你需要会的东西, 使用的技能, 这时你才发现自己是真的稚嫩. 学校安排学习的内容是早二三十年早已跟社会脱节的人制定的, 技术的世界日新月异, 你拿什么跟他们争呢?&lt;/p&gt;
&lt;p&gt;四年时间, 比一万小时定律还宽裕的时间, 足以让一个人成为某一领域的佼佼者, 但是实际上毕业的时候呢, 像我读的这样中等偏上的大学中, 应届生的平均能力真的令人叹息. 我看到最多的就是对自己的迷茫, 对人生的迷茫, 用四年的时间依然没有找到自己想走的方向. 最后20出头的年纪级就选择了户口, 稳定, 轻松简单的工作, 我也不敢说这样的路正不正确, 因为我也年轻, 还没到后悔的年纪, 但是如果是我, 我只是觉得走这样路我会有点亏. 也许未来我会后悔.&lt;/p&gt;
&lt;p&gt;在学术道路和职业道路的选择中, 其实只要一个月时间, 大部分人都能找到自己的答案,  但是人们依然前赴后继去考研. 我当时也是这样, 要是问我原因的话, 我应该和大部分人一样, 首先我回答不清楚这个问题, 然后带着迷茫地告诉你研究生是现在社会对人才的基本要求… 我特么还考了两次, 差点还考第三次… 可是我根本不喜欢搞学术, 我就喜欢写代码, 当码农, 想写一辈子代码, 这一点在高中时候参加NOIP的时候我就想清楚的事情, 隔了这么久居然给忘了…&lt;/p&gt;
&lt;p&gt;并不是在说知识无用, 知识任何时候都是最好的资本, 技术永远是推动社会前进的最大动力. 只是知识不是只有在大学四年里才能获得的, 教育制度的好赖公平与否不由我们说的算, 是否过时也无从得证, 毕竟每年有那么多人才从大学走出. 但是学习的自主权是真真实实在每个人自己手上的, 可以是按兴趣, 也可以是职业规划要求, 哪怕从事职业多年之后再去深造学术. 当你发现没有什么能限制你去学习的时候, 你才真的明白了自己为何而学, 才不会被制度的镣铐锁住手脚. 你是理科, 也可以去学艺术, 你读文学, 一样可以写出美妙的代码. 不给自己设限, 终身学习, 不断学习, 才能到达自己的巅峰, 同时充满快乐. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[Node.js Streams 中的背压(backpressure)]]></title><description><![CDATA[原文 数据处理过程中经常出现一个称为背压(backpressure…]]></description><link>https://lqs469.github.io/Backpressure/</link><guid isPermaLink="false">https://lqs469.github.io/Backpressure/</guid><pubDate>Tue, 03 Jul 2018 21:09:32 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://nodejs.org/en/docs/guides/backpressuring-in-streams/&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据处理过程中经常出现一个称为&lt;strong&gt;背压(backpressure)&lt;/strong&gt;的常见问题，用来描述数据传输过程中缓冲区后面的数据累积。当传送的接收端操作复杂时，或者由于某种原因而较慢时，来自传入源的数据有积聚的趋势，如堵塞。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，必须有一个授权系统来确保从一个源到另一个源的数据的平滑流动。不同的社区有根据其程序特点的独特解决方案，Unix pipes 和 TCP sockets 就是这方面的很好的例子，并且通常被称为流量控制。在Node.js中，Stream 是已被采用的解决方案。&lt;/p&gt;
&lt;p&gt;本指南的目的是进一步详细说明背压是什么，以及流如何在Node.js的源代码中解决这个问题。本指南的第二部分将介绍建议的最佳实践，以确保您的应用程序的代码在实现流时安全和优化。&lt;/p&gt;
&lt;p&gt;我们假设身为读者的你对 Node.js 中背压，&lt;code class=&quot;language-text&quot;&gt;Buffer&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;EventEmitters&lt;/code&gt; 的一般定义以及 Stream 的一些经验有点熟悉。如果您还没有阅读这些文档，首先查看API文档并不是一个坏主意，因为这将有助于在阅读本指南时扩展您的理解。&lt;/p&gt;
&lt;h2&gt;数据处理的问题&lt;/h2&gt;
&lt;p&gt;在计算机系统中，数据通过管道，套接字和信号(pipes, sockets, and signals)从一个进程传输到另一个进程。在 Node.js 中，我们找到了一个名为 Stream 的类似机制。Stream 很棒！他们为 Node.js 做了很多工作，几乎内部代码库的每个部分都利用该模块。作为一名开发人员，鼓励您去使用它们！&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; readline &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;readline&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// process.stdin and process.stdout are both instances of Streams&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; rl &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; readline&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createInterface&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  input&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; process&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;stdin&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  output&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; process&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;stdout
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

rl&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;question&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Why should you use streams? &apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;answer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;Maybe it&apos;s &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;answer&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;, maybe it&apos;s because they are awesome! :)&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  rl&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过比较 Node.js Stream 实现的内部系统工具，可以证明为什么通过 &lt;strong&gt;Stream&lt;/strong&gt; 实现 &lt;strong&gt;backpressure&lt;/strong&gt; 机制是一个很好的优化。&lt;/p&gt;
&lt;p&gt;在一种情况下，我们将采用大文件(大约9GB) 并使用熟悉的&lt;code class=&quot;language-text&quot;&gt;zip(1)&lt;/code&gt;工具对其进行压缩。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ zip The.Matrix.1080p.mkv&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然这需要几分钟的时间才能完成，在另一个shell中，我们可以运行一个采用 Node.js 的模块 &lt;code class=&quot;language-text&quot;&gt;zlib&lt;/code&gt; 的脚本，该脚本包含另一个压缩工具 &lt;code class=&quot;language-text&quot;&gt;gzip(1)&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; gzip &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;zlib&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createGzip&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; fs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;fs&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; inp &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createReadStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;The.Matrix.1080p.mkv&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; out &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createWriteStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;The.Matrix.1080p.mkv.gz&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

inp&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gzip&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后来验证结果，尝试打开每个压缩文件。由 &lt;code class=&quot;language-text&quot;&gt;zip(1)&lt;/code&gt; 工具压缩的文件将通知您文件已损坏，而由 Stream 完成的压缩将无错地解压缩。&lt;/p&gt;
&lt;p&gt;注意：在本例中，我们使用 &lt;code class=&quot;language-text&quot;&gt;.pipe()&lt;/code&gt; 从一端到另一端获取数据源。但是，请注意，没有附加适当的错误处理程序。如果大量数据无法正确接收，则可读源或 &lt;code class=&quot;language-text&quot;&gt;gzip&lt;/code&gt; 流不会被销毁。&lt;code class=&quot;language-text&quot;&gt;.pump&lt;/code&gt; 是一个很实用工具，如果其中一个失败或关闭，它将稳定无误地销毁管道中的所有流，并且在这种情况下是必须的！&lt;/p&gt;
&lt;h2&gt;数据太多, 太快&lt;/h2&gt;
&lt;p&gt;有些情况下，可读流可能太快地将数据提供给&lt;code class=&quot;language-text&quot;&gt;Writable&lt;/code&gt; - 远远超过消费者可以处理的数量！&lt;/p&gt;
&lt;p&gt;当发生这种情况时，消费者将开始排列所有数据块以供以后使用。写入队列将变得越来越长，并且因为这个更多的数据必须保存在内存中，直到整个过程完成。&lt;/p&gt;
&lt;p&gt;写入磁盘比从磁盘读取要慢很多，因此，当我们试图压缩文件并将其写入硬盘时，就会发生背压，因为写入磁盘将无法跟上速度阅读。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Secretly the stream is saying: &quot;whoa, whoa! hang on, this is way too much!&quot;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// Data will begin to build up on the read-side of the data buffer as&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// `write` tries to keep up with the incoming data flow.&lt;/span&gt;
inp&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gzip&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;outputFile&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是背压机制很重要的原因。如果背压系统不存在，这个过程将耗尽系统的内存，严重减缓其他的过程，并垄断大部分系统资源直到完成。&lt;/p&gt;
&lt;p&gt;结局如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;放慢所有其他现有流程&lt;/li&gt;
&lt;li&gt;一个非常劳累过度的垃圾收集器&lt;/li&gt;
&lt;li&gt;内存耗尽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在以下示例中，我们将取出&lt;code class=&quot;language-text&quot;&gt;.write()&lt;/code&gt; 函数的返回值并将其更改为 true，这有效地禁用了Node.js内核中的背压支持。在任何对“修改”二进制文件的引用中，我们都在讨论如何运行没有 &lt;code class=&quot;language-text&quot;&gt;return ret;&lt;/code&gt; 的节点二进制 (node binary) 文件线，而替换为 &lt;code class=&quot;language-text&quot;&gt;return true&lt;/code&gt; ;&lt;/p&gt;
&lt;h2&gt;过量的垃圾收集&lt;/h2&gt;
&lt;p&gt;让我们看看一个快速的基准。使用上面的同一个例子，我们进行了几次试验，以获得两个二进制文件的中位时间。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;   trial (#)  | `node` binary (ms) | modified `node` binary (ms)
=================================================================
      1       |      56924         |           55011
      2       |      52686         |           55869
      3       |      59479         |           54043
      4       |      54473         |           55229
      5       |      52933         |           59723
=================================================================
average time: |      55299         |           55975&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两者都花费一分钟左右的时间，所以根本没什么区别，但让我们仔细观察一下，以确认我们的猜测是否正确。我们使用 Linux 工具 &lt;code class=&quot;language-text&quot;&gt;dtrace&lt;/code&gt; 来评估V8垃圾收集器的情况。&lt;/p&gt;
&lt;p&gt;GC（垃圾回收器）测量的时间表示垃圾收集器完成的单次扫描的完整周期的时间间隔：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;approx. time (ms) | GC (ms) | modified GC (ms)
=================================================
          0       |    0    |      0
          1       |    0    |      0
         40       |    0    |      2
        170       |    3    |      1
        300       |    3    |      1

         *             *           *
         *             *           *
         *             *           *

      39000       |    6    |     26
      42000       |    6    |     21
      47000       |    5    |     32
      50000       |    8    |     28
      54000       |    6    |     35&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然这两种方法的起始时间相同，并且似乎以相同的速度工作，但显然在几秒钟后使用正确工作的反压系统GC负荷会以4-8毫秒的间隔持续扩散，直到数据传输结束。&lt;/p&gt;
&lt;p&gt;但是，当背压系统不在时，V8垃圾回收系统开始拖延。正常的二进制文件在一分钟内调用GC约75次，而修改后的二进制文件只触发36次。&lt;/p&gt;
&lt;p&gt;这是由于记忆体使用量增加而累积的缓慢而渐进的债务。随着数据的传输，如果没有背压系统，每个块传输都会使用更多的内存。&lt;/p&gt;
&lt;p&gt;分配的内存越多，GC就必须在一次扫描中处理得越多。扫描越大，GC需要决定什么可以释放，并且在更大的内存空间中扫描分离的指针会消耗更多的计算能力。&lt;/p&gt;
&lt;h2&gt;内存耗尽&lt;/h2&gt;
&lt;p&gt;为了确定每个二进制文件的内存消耗，我们为每个进程分别设定了&lt;code class=&quot;language-text&quot;&gt;/usr/bin/time -lp sudo ./node ./backpressure-example/zlib.js&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这是正常二进制的输出：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Respecting the return value of .write()
=============================================
real        58.88
user        56.79
sys          8.79
  87810048  maximum resident set size
         0  average shared memory size
         0  average unshared data size
         0  average unshared stack size
     19427  page reclaims
      3134  page faults
         0  swaps
         5  block input operations
       194  block output operations
         0  messages sent
         0  messages received
         1  signals received
        12  voluntary context switches
    666037  involuntary context switches&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虚拟内存占用的最大字节大小约为87.81 mb。 现在改变 &lt;code class=&quot;language-text&quot;&gt;.write()&lt;/code&gt; 函数的返回值，我们得到：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Without respecting the return value of .write():
==================================================
real        54.48
user        53.15
sys          7.43
1524965376  maximum resident set size
         0  average shared memory size
         0  average unshared data size
         0  average unshared stack size
    373617  page reclaims
      3139  page faults
         0  swaps
        18  block input operations
       199  block output operations
         0  messages sent
         0  messages received
         1  signals received
        25  voluntary context switches
    629566  involuntary context switches&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虚拟内存占用的最大字节大小约为1.52 gb。&lt;/p&gt;
&lt;p&gt;如果没有适当的 Stream backpressure，分配的内存空间就会增加一个数量级 - 这是同一过程之间的巨大差异！&lt;/p&gt;
&lt;p&gt;这个实验展示了 Node.js 的背压机制是如何针对您的计算系统优化和具有成本效益的。现在，让我们分析一下它的工作原理！&lt;/p&gt;
&lt;h2&gt;背压是如何解决这些问题的?&lt;/h2&gt;
&lt;p&gt;有不同的功能将数据从一个进程传输到另一个进程。在Node.js中，有一个名为&lt;code class=&quot;language-text&quot;&gt;.pipe()&lt;/code&gt;的内部内置函数。还有其他的软件包也可以使用！但最终，在这个过程的基本层面上，我们有两个独立的组件：数据源和消费者。&lt;/p&gt;
&lt;p&gt;当从源调用&lt;code class=&quot;language-text&quot;&gt;.pipe()&lt;/code&gt;时，它向消费者发出信号，告知有数据要传输。管道功能有助于为事件触发器设置适当的背压闭合。&lt;/p&gt;
&lt;p&gt;在Node.js中，源是可读流，而消费者是可写流（这两者可以与双工或转换流互换，但对于本指南而言，这是超出范围的）。&lt;/p&gt;
&lt;p&gt;触发背压的时刻可以精确地缩小到Writable的&lt;code class=&quot;language-text&quot;&gt;.write()&lt;/code&gt;函数的返回值。当然，这个返回值由几个条件决定。&lt;/p&gt;
&lt;p&gt;在数据缓冲区已超过&lt;code class=&quot;language-text&quot;&gt;highWaterMark&lt;/code&gt;或写入队列当前正忙的任何情况下，&lt;code class=&quot;language-text&quot;&gt;.write()&lt;/code&gt;将返回&lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当返回错误值时，背压系统启动。它将暂停传入的可读流发送任何数据并等待消费者再次准备就绪。清空数据缓冲区后，将发出&lt;code class=&quot;language-text&quot;&gt;.drain()&lt;/code&gt;事件并恢复传入的数据流。&lt;/p&gt;
&lt;p&gt;队列完成后，背压将允许再次发送数据。正在使用的内存空间将自行释放并为下一批数据做好准备。&lt;/p&gt;
&lt;p&gt;这有效地允许在任何给定时间为&lt;code class=&quot;language-text&quot;&gt;.pipe()&lt;/code&gt;函数使用固定数量的内存。没有内存泄漏，没有无限缓冲，垃圾收集器只需要处理内存中的一个区域！&lt;/p&gt;
&lt;p&gt;那么，如果背压如此重要，为什么你（可能）没有听说过它？那么答案很简单：Node.js自动完成所有这些。&lt;/p&gt;
&lt;p&gt;太棒了！但是当我们试图理解如何实现我们自己的自定义流时也不是那么好。&lt;/p&gt;
&lt;p&gt;注意：在大多数机器中，有一个字节大小决定缓冲区何时已满（这将在不同的机器上有所不同）。 Node.js允许您设置自己的自定义highWaterMark，但通常，默认设置为16kb（对于objectMode流，为16384或16）。在某些情况下，您可能需要提高该值，但请谨慎行事！&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;.pipe()&lt;/code&gt;的生命周期&lt;/h2&gt;
&lt;p&gt;为了更好地理解背压，下面是一个可读流的生命周期的流程图，该流被导入到可写流中：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;                                                     +===================+
                         x--&amp;gt;  Piping functions   +--&amp;gt;   src.pipe(dest)  |
                         x     are set up during     |===================|
                         x     the .pipe method.     |  Event callbacks  |
  +===============+      x                           |-------------------|
  |   Your Data   |      x     They exist outside    | .on(&amp;#39;close&amp;#39;, cb)  |
  +=======+=======+      x     the data flow, but    | .on(&amp;#39;data&amp;#39;, cb)   |
          |              x     importantly attach    | .on(&amp;#39;drain&amp;#39;, cb)  |
          |              x     events, and their     | .on(&amp;#39;unpipe&amp;#39;, cb) |
+---------v---------+    x     respective callbacks. | .on(&amp;#39;error&amp;#39;, cb)  |
|  Readable Stream  +----+                           | .on(&amp;#39;finish&amp;#39;, cb) |
+-^-------^-------^-+    |                           | .on(&amp;#39;end&amp;#39;, cb)    |
  ^       |       ^      |                           +-------------------+
  |       |       |      |
  |       ^       |      |
  ^       ^       ^      |    +-------------------+         +=================+
  ^       |       ^      +----&amp;gt;  Writable Stream  +---------&amp;gt;  .write(chunk)  |
  |       |       |           +-------------------+         +=======+=========+
  |       |       |                                                 |
  |       ^       |                              +------------------v---------+
  ^       |       +-&amp;gt; if (!chunk)                |    Is this chunk too big?  |
  ^       |       |     emit .end();             |    Is the queue busy?      |
  |       |       +-&amp;gt; else                       +-------+----------------+---+
  |       ^       |     emit .write();                   |                |
  |       ^       ^                                   +--v---+        +---v---+
  |       |       ^-----------------------------------&amp;lt;  No  |        |  Yes  |
  ^       |                                           +------+        +---v---+
  ^       |                                                               |
  |       ^               emit .pause();          +=================+     |
  |       ^---------------^-----------------------+  return false;  &amp;lt;-----+---+
  |                                               +=================+         |
  |                                                                           |
  ^            when queue is empty     +============+                         |
  ^------------^-----------------------&amp;lt;  Buffering |                         |
               |                       |============|                         |
               +&amp;gt; emit .drain();       |  ^Buffer^  |                         |
               +&amp;gt; emit .resume();      +------------+                         |
                                       |  ^Buffer^  |                         |
                                       +------------+   add chunk to queue    |
                                       |            &amp;lt;---^---------------------&amp;lt;
                                       +============+&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：如果您正在设置一个管道以将几个流链接在一起来操纵数据，那么您很可能会实现Transform流。&lt;/p&gt;
&lt;p&gt;在这种情况下，来自可读流的输出将输入到Transform中，并将流入Writable。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Readable.pipe(Transformable).pipe(Writable);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;背压将自动应用，但请注意转换流的输入和输出&lt;code class=&quot;language-text&quot;&gt;highWaterMark&lt;/code&gt;可能会被操纵，并会影响反压系统。&lt;/p&gt;
&lt;h2&gt;背压指南&lt;/h2&gt;
&lt;p&gt;由于Node.js v0.10，Stream类提供了使用这些函数（&lt;code class=&quot;language-text&quot;&gt;._read()和._write()&lt;/code&gt;）的下划线版本来修改&lt;code class=&quot;language-text&quot;&gt;.read()&lt;/code&gt;或&lt;code class=&quot;language-text&quot;&gt;.write()&lt;/code&gt;的行为的功能。 。&lt;/p&gt;
&lt;p&gt;有关于实现可读流和实现可写流的指导文件。我们假设你已经阅读了这些内容，下一节将更深入一点。&lt;/p&gt;
&lt;h2&gt;实现自定义流时遵守的规则&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Stream&lt;/code&gt;的黄金法则是始终尊重背压。最佳实践的构成是非矛盾的做法。只要你小心避免与内部背压支持相冲突的行为，就可以确定你正在遵循良好的做法。&lt;/p&gt;
&lt;p&gt;一般来说:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果没有询问，请不要使用&lt;code class=&quot;language-text&quot;&gt;.push()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;永远不要在返回false后调用&lt;code class=&quot;language-text&quot;&gt;.write()&lt;/code&gt;，而是等待’drain’。&lt;/li&gt;
&lt;li&gt;Streams在不同的Node.js版本和您使用的库之间进行更改。要小心注意并测试一下。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：关于第3点，构建浏览器流的非常有用的包是&lt;code class=&quot;language-text&quot;&gt;readable-stream&lt;/code&gt;。 Rodd Vagg撰写了一篇很棒的博客文章，描述了这个库的实用性。简而言之，它为可读流提供了一种自动优雅降级，并支持旧版本的浏览器和Node.js.&lt;/p&gt;
&lt;h2&gt;可读流的特定规则&lt;/h2&gt;
&lt;p&gt;到目前为止，我们已经了解了&lt;code class=&quot;language-text&quot;&gt;.write()&lt;/code&gt;如何影响背压，并将重点放在&lt;code class=&quot;language-text&quot;&gt;Writable&lt;/code&gt;流上。由于Node.js的功能，数据在技术上从可读流向下游流向可写。但是，正如我们可以在数据，物质或能量的任何传输中观察到的那样，源与目标一样重要，可读流对于如何处理背压至关重要。&lt;/p&gt;
&lt;p&gt;这两个进程都依赖于另一个进行有效的通信，如果&lt;code class=&quot;language-text&quot;&gt;Readable&lt;/code&gt;忽略了当&lt;code class=&quot;language-text&quot;&gt;Writable&lt;/code&gt;流要求它停止发送数据时，它可能与&lt;code class=&quot;language-text&quot;&gt;.write()&lt;/code&gt;的返回值不正确时一样有问题。&lt;/p&gt;
&lt;p&gt;因此，在尊重&lt;code class=&quot;language-text&quot;&gt;.write()&lt;/code&gt;返回时，我们还必须尊重&lt;code class=&quot;language-text&quot;&gt;._read()&lt;/code&gt;方法中使用的&lt;code class=&quot;language-text&quot;&gt;.push()&lt;/code&gt;的返回值。如果&lt;code class=&quot;language-text&quot;&gt;.push()&lt;/code&gt;返回一个假值，则该流将停止从源读取。否则，它将继续而不会暂停。&lt;/p&gt;
&lt;p&gt;这有个使用&lt;code class=&quot;language-text&quot;&gt;.push()&lt;/code&gt;的反例&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// This is problematic as it completely ignores return value from push
// which may be a signal for backpressure from the destination stream!
class MyReadable extends Readable {
  _read(size) {
    let chunk;
    while (null !== (chunk = getNextChunk())) {
      this.push(chunk);
    }
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，从定制流的外部来看，忽视背压是非常重要的。在这个良好实践的反例中，应用程序的代码在数据可用时强制数据（由&lt;code class=&quot;language-text&quot;&gt;.data&lt;/code&gt;事件发送信号）：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// This ignores the backpressure mechanisms Node.js has set in place,
// and unconditionally pushes through data, regardless if the
// destination stream is ready for it or not.
readable.on(&amp;#39;data&amp;#39;, (data) =&amp;gt;
  writable.write(data)
);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;可写流的特定规则&lt;/h2&gt;
&lt;p&gt;回想一下&lt;code class=&quot;language-text&quot;&gt;.write()&lt;/code&gt;可能会根据某些条件返回true或false。幸运的是，在构建我们自己的可写流时，流状态机将处理我们的回调并确定何时处理背压并为我们优化数据流。&lt;/p&gt;
&lt;p&gt;但是，当我们想直接使用Writable时，我们必须尊重&lt;code class=&quot;language-text&quot;&gt;.write()&lt;/code&gt;返回值并密切注意这些条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果写队列忙，.&lt;code class=&quot;language-text&quot;&gt;write()&lt;/code&gt;将返回false。&lt;/li&gt;
&lt;li&gt;如果数据块太大，&lt;code class=&quot;language-text&quot;&gt;.write()&lt;/code&gt;将返回false（该值由变量highWaterMark指示）。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// This writable is invalid because of the async nature of JavaScript callbacks.
// Without a return statement for each callback prior to the last,
// there is a great chance multiple callbacks will be called.
class MyWritable extends Writable {
  _write(chunk, encoding, callback) {
    if (chunk.toString().indexOf(&amp;#39;a&amp;#39;) &amp;gt;= 0)
      callback();
    else if (chunk.toString().indexOf(&amp;#39;b&amp;#39;) &amp;gt;= 0)
      callback();
    callback();
  }
}

// The proper way to write this would be:
    if (chunk.contains(&amp;#39;a&amp;#39;))
      return callback();
    else if (chunk.contains(&amp;#39;b&amp;#39;))
      return callback();
    callback();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实现&lt;code class=&quot;language-text&quot;&gt;._writev()&lt;/code&gt;时还需要注意一些事项。该函数与&lt;code class=&quot;language-text&quot;&gt;.cork()&lt;/code&gt;结合使用，但写入时常见错误：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// Using .uncork() twice here makes two calls on the C++ layer, rendering the
// cork/uncork technique useless.
ws.cork();
ws.write(&amp;#39;hello &amp;#39;);
ws.write(&amp;#39;world &amp;#39;);
ws.uncork();

ws.cork();
ws.write(&amp;#39;from &amp;#39;);
ws.write(&amp;#39;Matteo&amp;#39;);
ws.uncork();

// The correct way to write this is to utilize process.nextTick(), which fires
// on the next event loop.
ws.cork();
ws.write(&amp;#39;hello &amp;#39;);
ws.write(&amp;#39;world &amp;#39;);
process.nextTick(doUncork, ws);

ws.cork();
ws.write(&amp;#39;from &amp;#39;);
ws.write(&amp;#39;Matteo&amp;#39;);
process.nextTick(doUncork, ws);

// as a global function
function doUncork(stream) {
  stream.uncork();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;.cork()&lt;/code&gt;可以被调用多次，我们只需要小心调用&lt;code class=&quot;language-text&quot;&gt;.uncork()&lt;/code&gt;相同的次数，使其再次流动。&lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;Streams是Node.js中经常使用的模块。它们对于内部结构非常重要，对于开发人员来说，它们可以跨Node.js模块生态系统进行扩展和连接。&lt;/p&gt;
&lt;p&gt;希望您现在能够排除故障，安全地编写您自己的可写和可读流的背景，并与同事和朋友分享您的知识。&lt;/p&gt;
&lt;p&gt;在使用Node.js构建应用程序时，请务必阅读有关其他API函数的Stream的更多信息，以帮助改进和释放您的流功能。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JavaScript ES2018/ES9 新增标准]]></title><description><![CDATA[6 月 27 号, TC39 正式完成了ES2018/ES9 的语言规范 开始进入 ES2019 阶段.
最终阶段详情: finished-proposals
来看看 ES2018 比之前的 ES2017 新增了哪些规范. Object Rest/Spread…]]></description><link>https://lqs469.github.io/JavaScript-ES2018-ES9-新增标准/</link><guid isPermaLink="false">https://lqs469.github.io/JavaScript-ES2018-ES9-新增标准/</guid><pubDate>Fri, 29 Jun 2018 22:14:06 GMT</pubDate><content:encoded>&lt;p&gt;6 月 27 号, TC39 正式完成了&lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ES2018/ES9 的语言规范&lt;/a&gt; 开始进入 ES2019 阶段.
最终阶段详情: &lt;a href=&quot;https://github.com/tc39/proposals/blob/master/finished-proposals.md&quot;&gt;finished-proposals&lt;/a&gt;
来看看 ES2018 比之前的 ES2017 新增了哪些规范.&lt;/p&gt;
&lt;h2&gt;Object Rest/Spread Properties&lt;/h2&gt;
&lt;p&gt;对于对象的 Rest/Spread, 而之前标准只有数组是支持的. 说出来你可能不信, 这是 ES9 的特性, 我感觉都已经用了很久了…&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;x&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; z&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;rest&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; obj
&lt;span class=&quot;token comment&quot;&gt;// x = 1, rest = { y: 2, z: 3 }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很实用的一点比如 React props 可以这样写&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;props &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props
	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Asynchronous Iteration 异步迭代器&lt;/h2&gt;
&lt;p&gt;神奇的异步迭代器, 如果你之前这样写, 循环会依旧保持同步, 而异步独立于循环外, 为什么会导致这个情况想明白这个机制的同学可以去了解一下 js 事件循环.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; line &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;readLines&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;file&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;token comment&quot;&gt;// line by line&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Promise.prototype.finally()&lt;/h2&gt;
&lt;p&gt;又一个以为早就有的特性, 当&lt;code class=&quot;language-text&quot;&gt;promise&lt;/code&gt;结束时稳定被触发(无论&lt;code class=&quot;language-text&quot;&gt;resolve&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;reject&lt;/code&gt;), 几乎是扫尾工作专用方法.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;finally&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Fn&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;一系列正则优化&lt;/h2&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;s&lt;/code&gt; 标志和 &lt;code class=&quot;language-text&quot;&gt;dotAll&lt;/code&gt; 模式&lt;/h3&gt;
&lt;p&gt;之前 &lt;code class=&quot;language-text&quot;&gt;.&lt;/code&gt; 用于匹配任何单字符, 但有两个例外:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;无法匹配行结束符&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token regex&quot;&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-source language-regex&quot;&gt;foo.bar&lt;/span&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;foo\nbar&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// → false&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;行终结符:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;U+000A LINE FEED (LF) (\n) - 换行&lt;/li&gt;
&lt;li&gt;U+000D CARRIAGE RETURN (CR) (\r) - 回车&lt;/li&gt;
&lt;li&gt;U+2028 LINE SEPARATOR - 行分隔符&lt;/li&gt;
&lt;li&gt;U+2029 PARAGRAPH SEPARATOR - 段分隔符
以及:&lt;/li&gt;
&lt;li&gt;U+000B VERTICAL TAB (\v)&lt;/li&gt;
&lt;li&gt;U+000C FORM FEED (\f)&lt;/li&gt;
&lt;li&gt;U+0085 NEXT LINE&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多字节字符(非 BMP), 比如 Emoji:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token regex&quot;&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-source language-regex&quot;&gt;^.$&lt;/span&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;😀&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// → false&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;曾经可以通过 &lt;code class=&quot;language-text&quot;&gt;/u&lt;/code&gt; 解决:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token regex&quot;&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-source language-regex&quot;&gt;^.$&lt;/span&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-flags&quot;&gt;u&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;😀&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// → true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而在 ES9 中，新增加了一个新的标志 &lt;code class=&quot;language-text&quot;&gt;s&lt;/code&gt;, 让 &lt;code class=&quot;language-text&quot;&gt;.&lt;/code&gt; 可以匹配任意单字符.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; re &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token regex&quot;&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-source language-regex&quot;&gt;foo.bar&lt;/span&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-flags&quot;&gt;s&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Or, `const re = new RegExp(&apos;foo.bar&apos;, &apos;s&apos;);`.&lt;/span&gt;
re&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;foo\nbar&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// → true&lt;/span&gt;
re&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dotAll
&lt;span class=&quot;token comment&quot;&gt;// → true&lt;/span&gt;
re&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;flags
&lt;span class=&quot;token comment&quot;&gt;// → &apos;s&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;命名捕获组(RegExp Named Capture Groups)&lt;/h3&gt;
&lt;p&gt;以前:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; regex &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token regex&quot;&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-source language-regex&quot;&gt;(\d{4})-(\d{2})-(\d{2})&lt;/span&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; matchers &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; regex&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;2015-01-02&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
matchers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 2015-01-02&lt;/span&gt;
matchers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 2015&lt;/span&gt;
matchers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 01&lt;/span&gt;
matchers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 02&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; re &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token regex&quot;&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-source language-regex&quot;&gt;(?&amp;lt;year&gt;\d{4})-(?&amp;lt;month&gt;\d{2})-(?&amp;lt;day&gt;\d{2})&lt;/span&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-flags&quot;&gt;u&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; re&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;2015-01-02&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// result.groups.year === &apos;2015&apos;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// result.groups.month === &apos;01&apos;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// result.groups.day === &apos;02&apos;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// result[0] === &apos;2015-01-02&apos;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// result[1] === &apos;2015&apos;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// result[2] === &apos;01&apos;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// result[3] === &apos;02&apos;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解构一起用:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  groups&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;one&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; two&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token regex&quot;&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-source language-regex&quot;&gt;^(?&amp;lt;one&gt;.*):(?&amp;lt;two&gt;.*)$&lt;/span&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-flags&quot;&gt;u&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;foo:bar&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;one: &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;one&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;, two: &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;two&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// prints one: foo, two: bar&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;反向引用:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let duplicate = /^(?&amp;lt;half&amp;gt;.*).\k&amp;lt;half&amp;gt;$/u;
duplicate.test(&amp;#39;a*b&amp;#39;); // false
duplicate.test(&amp;#39;a*a&amp;#39;); // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;跟数字捕获组一起使用:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let triplicate = /^(?&amp;lt;part&amp;gt;.*).\k&amp;lt;part&amp;gt;.\1$/u;
triplicate.test(&amp;#39;a*a*a&amp;#39;); // true
triplicate.test(&amp;#39;a*a*b&amp;#39;); // false&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;替换字符&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let re = /(?&amp;lt;year&amp;gt;\d{4})-(?&amp;lt;month&amp;gt;\d{2})-(?&amp;lt;day&amp;gt;\d{2})/u;
let result = &amp;#39;2015-01-02&amp;#39;.replace(re, &amp;#39;$&amp;lt;day&amp;gt;/$&amp;lt;month&amp;gt;/$&amp;lt;year&amp;gt;&amp;#39;);
// result === &amp;#39;02/01/2015&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;反向断言(RegExp Lookbehind Assertions)&lt;/h3&gt;
&lt;p&gt;以往只支持正向断言, 现在支持了反向断言, 语法是 &lt;code class=&quot;language-text&quot;&gt;(?&amp;lt;=...)&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token regex&quot;&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-source language-regex&quot;&gt;(?&amp;lt;=\$)\d+(\.\d*)?&lt;/span&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子会匹配 &lt;code class=&quot;language-text&quot;&gt;&amp;#39;$10.53&amp;#39;&lt;/code&gt; 捕获返回 &lt;code class=&quot;language-text&quot;&gt;&amp;#39;10.53&amp;#39;&lt;/code&gt;, 但不会匹配 &lt;code class=&quot;language-text&quot;&gt;€10.53&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Unicode转义(RegExp Unicode Property Escapes)&lt;/h3&gt;
&lt;p&gt;设置&lt;code class=&quot;language-text&quot;&gt;\p{Script_Extensions}&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;\P{Script_Extensions}&lt;/code&gt;, 使得在 JS 的正则中使用 Unicode 字符, 包括一些奇奇怪怪的字符. 举个例子比如希腊字母:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; regexGreekSymbol &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token regex&quot;&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-source language-regex&quot;&gt;\p{Script_Extensions=Greek}&lt;/span&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-flags&quot;&gt;u&lt;/span&gt;&lt;/span&gt;
regexGreekSymbol&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;π&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// → true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;目前大部分特性已经应用于主流浏览器了, 甚至有的早早就有, 也有一些正在实现过程中的. 但如果遇到要解决兼容性的问题还是得老老实实查 MDN, caniuse. 而 Node 端依然落后于标准设计, 这个有历史原因也有稳定性的要求. 新的标准出来的速度快其实大家也不用捉急, 原因在于生产中大部分时候我们其实用不到最新的标准, 或者已有其他的途径或老方法解决掉问题. 写出炫酷的代码不一定是最重要的, 能够解决掉问题才是最重要的. 而新标准更多的意义在于遇到真正刁钻问题的时候能够有解决方法或语言支持, 以及对代码抽象能力的提升, 性能的优化等.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Reach-Router指北]]></title><description><![CDATA[Reach-Router 是前 ReactRouter 成员 Ryan Florence 开发的一套基于 react 的路由控件. 那么已经有比较成熟的 ReactRouter 了, 为什么要”再”做一套 Router 呢, 最初的原因有兴趣(hào shi…]]></description><link>https://lqs469.github.io/Reach-Router“真香”/</link><guid isPermaLink="false">https://lqs469.github.io/Reach-Router“真香”/</guid><pubDate>Tue, 05 Jun 2018 15:03:29 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src=&quot;/679f2858c4fa2dd342df5fc27b44dcc2/3910365c6be928469d0afb130c0ccee3.gif&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://reach.tech/router&quot;&gt;Reach-Router&lt;/a&gt; 是&lt;strong&gt;前&lt;/strong&gt; ReactRouter 成员 Ryan Florence 开发的一套基于 react 的路由控件. 那么已经有比较成熟的 ReactRouter 了, 为什么要”再”做一套 Router 呢, 最初的原因有兴趣(hào shi)的同学可以去了解一下, 本文会介绍 ReachRouter 并且说明具体比 React-Router 好在哪里.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Overview&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a1ae7f25f0842a04f991cc43c8a25bc5/2a195/7B44554A-6DDF-4F85-B1C8-263D85F6EB43.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 39.189189189189186%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsTAAALEwEAmpwYAAABI0lEQVQY042N0U7DIBSG+/5v4pUvYGLUxMQbExcrzK4dG7OU0XVrgVIoUI91Fxp34ZeTP4Sc7/wJJ1t8f/eE6c3jMynyFL3lRbHZbmEo3e2F4HzPGKuqisNr5qMsb19yY8eELdDr1TVmp0W2aWpRlqwsS87nXc6bpqnrGn5A/k44RCl9SIlxY2KV0aKdYpBdezgcTjOgQR6PRzDhjBC1EMJ7P/0msSHqMA3GpGmaZdlqtSqKAkwz0/dGKSWl0lqHEOIPZtkHPUZnB4QQmOATQtaEgB9DGJ2L3jtrwZz+cJYH02O8hM73LMPL5VcijLMcrWm+q1BOoPmiHJULU/CqbXuletlBtl3Xte1JqmYIjfHSXag9y9oF6TztBiYt5F7b6X98Atc9whN0MoDcAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;7B44554A 6DDF 4F85 B1C8 263D85F6EB43&quot;
        title=&quot;7B44554A 6DDF 4F85 B1C8 263D85F6EB43&quot;
        src=&quot;/static/a1ae7f25f0842a04f991cc43c8a25bc5/fcda8/7B44554A-6DDF-4F85-B1C8-263D85F6EB43.png&quot;
        srcset=&quot;/static/a1ae7f25f0842a04f991cc43c8a25bc5/12f09/7B44554A-6DDF-4F85-B1C8-263D85F6EB43.png 148w,
/static/a1ae7f25f0842a04f991cc43c8a25bc5/e4a3f/7B44554A-6DDF-4F85-B1C8-263D85F6EB43.png 295w,
/static/a1ae7f25f0842a04f991cc43c8a25bc5/fcda8/7B44554A-6DDF-4F85-B1C8-263D85F6EB43.png 590w,
/static/a1ae7f25f0842a04f991cc43c8a25bc5/2a195/7B44554A-6DDF-4F85-B1C8-263D85F6EB43.png 620w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从 RF 的 Tweet 上简单的发布可以看出来, ReachR (以下都简称 ReachR)主打的是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Accessibility, 也就是无障碍, 易用性.&lt;/li&gt;
&lt;li&gt;相对链接的跳转方式.&lt;/li&gt;
&lt;li&gt;嵌套的路由配置.&lt;/li&gt;
&lt;li&gt;合适的路径优先(顺序不会造成影响).&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们先不管这些 features 到底是什么, 我们先来看一看 ReachR 的设计意图: 根据作者的&lt;a href=&quot;https://reach.tech/router/credits&quot;&gt;原话&lt;/a&gt;, 整个 ReachR 项目是对 ReactR V3 和 V4 两个版本的一些优点的集成以及加入了一些作者一直想要的功能.&lt;/p&gt;
&lt;p&gt;那么跟 React-Router 比较一下呢:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尺寸. 更少的依赖和更少代码实现够用的功能, ReactR 代码约为 229KB, ReachR 代码为 193KB, 组件依赖也更少.&lt;/li&gt;
&lt;li&gt;没有复杂的路由模式. 没有多余的可选参数或类似的东西，只是静态路径，参数和尾随通配符。&lt;/li&gt;
&lt;li&gt;不支持 React-Native. 讲道理, 你的路由根本用不上支持 RN.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实我认为最重要的一点, ReachR 比 ReactR 对开发者来讲: &lt;strong&gt;更好用&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Under the hood&lt;/h2&gt;
&lt;p&gt;那么我们来具体看看 ReachRouter 的 API 设计:&lt;/p&gt;
&lt;h3&gt;渲染方法&lt;/h3&gt;
&lt;p&gt;跟 ReactRouter 不用在于, 在众多路由中只会根据 path 渲染一个最符合条件的子组件.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Home path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Dash path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;dashboard&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如图例, 组件直接加参数 path 的写法十分简洁, 当前 url 为 /dashboard 时, 只会渲染 Dash, 而当前 url = ‘/’ 时才会渲染 Home. 在 ReactRouter 中匹配则渲染的方式的确能解决一些组件复用的匹配情况, 然而我们遇到更多的情况则是希望专一的渲染单个组件.&lt;/p&gt;
&lt;h3&gt;Link 导航&lt;/h3&gt;
&lt;Link /&gt; 可以在任何位置放置, 没有限制, 不需要包裹进&lt;Router /&gt;.
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Link to&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Home&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Link&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Link to&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;dashboard&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Dashboard&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Link&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;通配符参数&lt;/h3&gt;
&lt;p&gt;通配符参数会直接注入 props, 用不着再 props.location…&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// at url &quot;/invoice/23&quot;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Home path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Invoice path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;invoice/:invoiceId&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;Invoice&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;props&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Invoice &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;invoiceId&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其效果和 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Invoice invoiceId={23} /&amp;gt;&lt;/code&gt; 一样, 简洁直接.&lt;/p&gt;
&lt;h3&gt;“智能”匹配最合适的路径&lt;/h3&gt;
&lt;p&gt;这是 ReachRouter 一个很棒的特性, 如下面例子&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Home path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Invoice0 path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;:invoiceId&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Invoice1 path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;invoices&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Invoice2 path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/invoices&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当 url 为 ‘/invoices’ 这里谁更合适呢?
答: 渲染&amp;#x3C; Invoice1 /&gt;.
而当 url 为 ‘/123’ 会渲染 &lt;Invoice0 invoiceId={123} /&gt;.&lt;/p&gt;
&lt;p&gt;也就是说只有 url 准确匹配到 path 且为非通配符参数时, 会优先且只会渲染此组件, 而如果没有符合的 path, 才会去渲染包含通配符的组件, 这与顺序无关, 也就是说&lt;Invoice0 /&gt;, &lt;Invoice1 /&gt;交换顺序不会影响渲染逻辑.&lt;/p&gt;
&lt;p&gt;但是如果&lt;Invoice1 /&gt;, &lt;Invoice2 /&gt;交换顺序, 结果会怎么样呢?
答: 渲染第一个匹配的 path. 当 url = ‘/Invoices’ 时, 渲染第一个 path=‘invoices’ 或者 ’/invoices’ 的组件(二者是一样的, 所以匹配遇到的第一个).&lt;/p&gt;
&lt;p&gt;这一特性对比 ReactRouter V4 的实现, 不仅逻辑简单清晰, 还能够省下一个&lt;Switch /&gt;(不一定).&lt;/p&gt;
&lt;h3&gt;嵌套路由和嵌套子组件&lt;/h3&gt;
&lt;p&gt;这是 ReachRouter 相比最能体现其优点的地方. 嵌套组件在 Route 中, 它的 path 也会遵循嵌套, 并且其匹配的子组件将作为 props.children 传递.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;Dash&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;children&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Dashboard&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;hr &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;children&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Home path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Dash path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;dashboard&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Invoices path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;invoices&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Team path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;team&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Dash&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果 url 是 ’/dashboard/invoices’, 则将渲染 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Dash&amp;gt;&amp;lt;Invoices/&amp;gt;&amp;lt;/Dash&amp;gt;&lt;/code&gt;. 如果它只是“/dashboard”, 子组件将不会被渲染, 只有 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Dash /&amp;gt;&lt;/code&gt; 出现.&lt;/p&gt;
&lt;p&gt;并且基于这个特性我们终于可以在子路由内用 “/” 了&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Dash path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;dashboard&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;DashboardGraphs path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;InvoiceList path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;invoices&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Dash&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;组件逻辑关系一目了然, 是一个特别好用且经常用到的场景.&lt;/p&gt;
&lt;h3&gt;相对链接&lt;/h3&gt;
&lt;p&gt;子组件内的导航可以直接使用子组件的 path 来作为 to 的参数. 也就是相对链接(Relative Links), 当父组件的 path 改变时或者组件被移动到别处时, 这个特性显得很有用.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Home path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Dash path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;dashboard&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Invoices path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;invoices&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Team path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;team&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Dash&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;Dash&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;children&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Dashboard&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;nav&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Link to&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;invoices&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Invoices&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Link&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Link to&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;team&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Team&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Link&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;nav&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;hr &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;children&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;Dash /&gt;内的&lt;Link /&gt;不需要 to=‘/dashboard/invoices’ 而是直接 to=‘invoices’ 即可.&lt;/p&gt;
&lt;h3&gt;404 NotFound&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Home path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;NotFound &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;真的, 非常简洁.&lt;/p&gt;
&lt;h3&gt;支持多个 Router&lt;/h3&gt;
&lt;p&gt;如果你想要在应用中匹配多处的组件, 可以直接使用多个&lt;Router /&gt;. 这一点在导航菜单里非常常见.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Sidebar&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Router primary&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;HomeNav path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;DashboardNav path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;dashboard&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Sidebar&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;MainScreen&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Home path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
          &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;About path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;about&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Home&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Dash path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;dashboard&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
          &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Invoices path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;invoices&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
          &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Team path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;team&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Dash&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;MainScreen&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你想要在一个&lt;Router /&gt;内部嵌套另一个&lt;Router /&gt;的话, 需要把外层的 path 加上一个 ‘/*’, 就能做到跟没有&amp;#x3C;Router/ &gt;一样效果的 path 嵌套, 这么实现对于组件复用或者在大型应用多代码模块分别开发有奇效.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Home path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Dash path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;dashboard/*&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;Dash&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt; nested router&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;DashboardGraphs path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;InvoiceList path&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;invoices&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Router&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;导航控制&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;navigate&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;@reach/router&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;Invoices&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;NewInvoiceForm
      onSubmit&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; newInvoice &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createInvoice&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;event&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;target&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;navigate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;/invoices/&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;newInvoice&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就一个 &lt;code class=&quot;language-text&quot;&gt;navigate&lt;/code&gt; 函数, 够用了. 或者这样用: &lt;code class=&quot;language-text&quot;&gt;props.navigate&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;Invoices&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;navigate&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;NewInvoiceForm
      onSubmit&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; newInvoice &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createInvoice&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;event&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;target&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// can navigate to relative paths&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;navigate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;newInvoice&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Navigate&lt;/code&gt; 会返回一个 Promise. 这表示可以使用迭代去控制页面的转场效果以及准确的数据流向, 使得和 react 的生命周期的配合变得非常流畅.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Invoices&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Component&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  state &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    creatingNewInvoice&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;LoadingBar animate&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;creatingNewInvoice&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;NewInvoiceForm
          onSubmit&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
              creatingNewInvoice&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; newInvoice &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createInvoice&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;event&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;target&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;navigate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;/invoice/&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;newInvoice&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
              creatingNewInvoice&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;InvoiceList &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就这些!&lt;/p&gt;
&lt;h2&gt;In the end&lt;/h2&gt;
&lt;p&gt;在应用中, 一个 Router 只需要保证基本功能且稳定就足够了, ReachRouter 很好的做到了这一点. 以上是他对比于 ReactRouter 的一些优化特性. 解决了一系列备受吐槽的 ReactRouter V4 的奇葩设计. 总的来说, 够用且好用是 ReachRouter 的精髓, API 非常清晰且高效. 轮子年年有, 今年特别多, 现在尚不可预测未来 ReachRouter 会不会取代 ReactRouter, 但是其中的很多特性在前端路由模块的设计中很有意义, 作者也是这方面的带路者, 推荐大家去了解一下.&lt;/p&gt;
&lt;p&gt;除此以上 API 之外, ReachRouter 也有 Server Rendering API, navigate API, LocationProvider, createHistory 等前作实现的功能点保留下来, 并且都有部分优化. 感兴趣的同学可以去学习一发.✌️&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Reactv16.3的新生命周期]]></title><description><![CDATA[随着 react 16 版本的不断迭代, 更多新的特性也逐渐稳定下来. 本文主要介绍 react 16.3 版本中官方已经稳定下的新版生命周期. 新生命周期模型 为了配合异步渲染机制, 并且简化渲染更新流程, react…]]></description><link>https://lqs469.github.io/Reactv16-3的新生命周期/</link><guid isPermaLink="false">https://lqs469.github.io/Reactv16-3的新生命周期/</guid><pubDate>Thu, 19 Apr 2018 08:58:57 GMT</pubDate><content:encoded>&lt;p&gt;随着 react 16 版本的不断迭代, 更多新的特性也逐渐稳定下来. 本文主要介绍 react 16.3 版本中官方已经稳定下的新版生命周期.&lt;/p&gt;
&lt;h3&gt;新生命周期模型&lt;/h3&gt;
&lt;p&gt;为了配合异步渲染机制, 并且简化渲染更新流程, react 将去除三种生命周期方法, 加入两种生命周期方法. 在逐渐替换的版本迭代中, 旧版本将方法定位为不安全, 未来将不再继续维护, 预计下一次大版本更新会被废除.&lt;/p&gt;
&lt;p&gt;在这个示意图中能够很清晰的看到改版后的组件渲染更新和数据之间的逻辑和生命周期的步骤:
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.4054054054054%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/UlEQVQoz22S65KiMBCFef+Hc5zSGV1BQRAJ4ZZASAAvZ7vjWDs/lqquQJP+cvqkg+fzCX4ejweccxBFgSgM0bYtjDE+OF9Q/nA4QHWd/x7HEcMw4Or3R8iyzOcCBnIwcBgd8rJFFF8gmx79YHwRQzsCiUKg73ufG37+cb4sSy/AA/HraXuHMFPYhlek0tIB1m+UUmIgaFVV0Fr7Lt4dMIRXa+0LyKcIIei0Hh0Bk9Jid5KviCuEaYusclRk4cbBF76teKtn1W94cM2vWK1WyPOcvJmge4O66dB2Ck2rEOdkQdYgLTpEqUSrGEYA3/Y/IMM88Ha7YZ5n8DpSi3oYqYh8MvxukZUa+5OgC7nglCvI9vVfaYb9B8iX4S/mcUetRiTCIi6Mb/0sHanrcEgb5NT2pZ4oZsTCoSSw+VHIvr5tCNjoJE78WLhpolhg6LZ5ZcV3l2PsQtTFF0S6Rn3dYtIR5lF6X9nTgZRa93oPJpop9sIXLwZYJEEEnrOE1SnmPoFVEZw6+riPKZ7ujPvUkE0PPx2/Zzmo6xq73Q6ilLgtdBIBdBPReoaqj2irVzQyhGqOmMwFs82xTB2meaFOLM2rhpsd5mVGwDK5bUsKO6PwGW2w2q/xnexhyYLK1IirBJvjFqs/a2xOXzg3KZTV5HmF9WFF8YHP8AOyK/EX54BCz8vOJAAAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;lifecycle&quot;
        title=&quot;lifecycle&quot;
        src=&quot;/static/f427f1e779602498d7cd3a411101caa7/fcda8/lifecycle.png&quot;
        srcset=&quot;/static/f427f1e779602498d7cd3a411101caa7/12f09/lifecycle.png 148w,
/static/f427f1e779602498d7cd3a411101caa7/e4a3f/lifecycle.png 295w,
/static/f427f1e779602498d7cd3a411101caa7/fcda8/lifecycle.png 590w,
/static/f427f1e779602498d7cd3a411101caa7/efc66/lifecycle.png 885w,
/static/f427f1e779602498d7cd3a411101caa7/c83ae/lifecycle.png 1180w,
/static/f427f1e779602498d7cd3a411101caa7/b5c8e/lifecycle.png 2194w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;
在线查看示意图: &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;React lifecycle methods diagram&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;计划去除的三个方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;componentWillMount&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;componentWillReceiveProps&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;componentWillUpdate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过在 v16 这个大版本这些方法都不会立刻废除, 有足够时间完成迁移工作, 只是都会增加一个别名( UNSAFE 前缀):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;componentWillMount&lt;/code&gt; -&gt; &lt;code class=&quot;language-text&quot;&gt;UNSAFE_componentWillMount&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;componentWillReceiveProps&lt;/code&gt;  -&gt; &lt;code class=&quot;language-text&quot;&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;componentWillUpdate&lt;/code&gt;  -&gt; &lt;code class=&quot;language-text&quot;&gt;UNSAFE_componentWillUpdate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 v16.3 包括之后的 v16版本两种写法你都可以使用, 不过在 v16.3 后面的版本使用旧的方法会得到一个警告. 而在 v17 版本将会彻底去掉旧方法, 只保留 UNSAFE 前缀的兼容方法.&lt;/p&gt;
&lt;h3&gt;新增了两个生命周期方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;getDerivedStateFromProps&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;getSnapshotBeforeUpdate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;getDerivedStateFromProps&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Example&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Component&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getDerivedStateFromProps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;nextProps&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; prevState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
	  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	    counter&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; prevState&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;counter&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
	  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;随着 &lt;code class=&quot;language-text&quot;&gt;componentWillReceiveProps&lt;/code&gt; 被废除, 接替前者地位的就是这个方法, 而且更加强大,  &lt;code class=&quot;language-text&quot;&gt;componentWillReceiveProps&lt;/code&gt;  只能在初次渲染之后的组件 props 更新时执行, 主要负责渲染之前的数据处理工作, 而 &lt;code class=&quot;language-text&quot;&gt;getDerivedStateFromProps&lt;/code&gt; 有着类似的功能, 但是在初次渲染和组件 props 更新都会被执行. 第一个参数是新传入的 props, 第二个参数是当前的 state. 他的返回和 &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt; 方法类似, 当返回 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt; 时不会更新任何状态, 而有返回的对象就内容是被更新的状态.&lt;/p&gt;
&lt;p&gt;值得注意的是, &lt;code class=&quot;language-text&quot;&gt;getDerivedStateFromProps&lt;/code&gt; 是一个静态方法(&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static&quot;&gt;static - JavaScript | MDN&lt;/a&gt;). 它不能直接在非静态方法中使用 this 关键字来访问, 也不能访问到 this 上的方法. 但其实我们没有必要在这个周期使用到 this 上的方法, 一个是我们本来不应该在这个环节进行逻辑处理, 而且实际上这个周期中的所有逻辑处理都可以放到下一个周期去做.&lt;/p&gt;
&lt;p&gt;如果你同时用了 &lt;code class=&quot;language-text&quot;&gt;getDerivedStateFromProps&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;componentWillReceiveProps&lt;/code&gt;, 那么只有 &lt;code class=&quot;language-text&quot;&gt;getDerivedStateFromProps&lt;/code&gt; 会起作用, 而且还会收到一个警告.&lt;/p&gt;
&lt;p&gt;你也可以使用静态方法的写法:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;Example&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;getDerivedStateFromProps&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;nextProps&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; prevState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;getSnapshotBeforeUpdate&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Example&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Component&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;getSnapshotBeforeUpdate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;prevProps&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; prevState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个新加入的周期, 基本上替代了方法 &lt;code class=&quot;language-text&quot;&gt;componentWillUpdate&lt;/code&gt;. 它发生在组件被渲染和更新之前的一点点, 是最贴近 VDOM 发生变化之前的一次执行方法. 参数是当前状态的 props, state 值. 他返回的值会被 &lt;code class=&quot;language-text&quot;&gt;componentDidUpdate&lt;/code&gt; 当做第三个参数.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;componentDidUpdate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;prevProps&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; prevState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; snapshot&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;snapshot &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;StrictMode&lt;/h3&gt;
&lt;p&gt;在版本迁移中, 我们可以使用官方提供的高亮组件工具来指导我们熟悉新的特性 —— &lt;code class=&quot;language-text&quot;&gt;StrictMode&lt;/code&gt;. 这个不会实际生成 DOM 的工具组件适用于在这个版本过渡阶段的开发环境中, 用于检查其子组件的是否存在问题, 并且高亮有问题的代码. 在 v16.3 中,  &lt;code class=&quot;language-text&quot;&gt;StrictMode&lt;/code&gt; 能够:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定使用了不安全的生命周期的组件&lt;/li&gt;
&lt;li&gt;高亮旧版不安全的 ref 用法&lt;/li&gt;
&lt;li&gt;检测意料之外的副作用&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;StrictMode&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  	&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;ComponentOne &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;ComponentTwo &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;StrictMode&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;以上就是 v16.3 生命周期的新特性, 以前的应用逻辑基本都能比较完美的转换成新的周期方法, 而且新周期会对以前代码逻辑规范有一定提升, 逻辑上较之前的逻辑更为清晰, 对于HOC, render props 都能够比较好的支持. 对于更具体场景的迁移方法请看官方提供的一个示例&lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#examples&quot;&gt;Update on Async Rendering - React Blog&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Jump]]></title><description><![CDATA[自从微信开放小游戏平台，跳一跳这个小清新（CHAOXI…]]></description><link>https://lqs469.github.io/跳一跳全自动化”辅助工具”iOS版/</link><guid isPermaLink="false">https://lqs469.github.io/跳一跳全自动化”辅助工具”iOS版/</guid><pubDate>Thu, 11 Jan 2018 22:41:57 GMT</pubDate><content:encoded>&lt;p&gt;自从微信开放小游戏平台，跳一跳这个小清新（CHAOXI）的小游戏突然火了起来，对于资深手残党的我来说，虽然只是简简单单的一按一放，但是有句古话说的好：“听过很多道理，依然过不好这一生”。无数次挫败的感觉让我想起来被魂系列折磨的一个个深夜… 随着各种各样的“辅助工具”也是层出不穷，我也决定抽业余时间也来实现了一个吧。使用JS实现，已开源，需要的同学自取：&lt;a href=&quot;https://github.com/lqs469/jump&quot;&gt;微信跳一跳全自动化“辅助”工具ios版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;话不多说，如图所示：
&lt;img src=&quot;/ffceeeef85c4fdeb17527be5ab9bd6c3/IMB_eQlAvL.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为手头只有iOS设备，所以只实现了iOS版。目前已经实现完全自动化（如图），安全上分，放心使用。ps: 这是外挂，好孩子不要学哦…..&lt;/p&gt;
&lt;h2&gt;解决思路&lt;/h2&gt;
&lt;p&gt;首先是解决连接问题，如何让我的程序能够触及设备。方法是使用WebDriverAgent调试工具，它能够模拟设备状态并提供可操作的接口。接下来：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用WDA提供的API完成截屏并输出。这一步得到跳跃前的状态以待分析。&lt;/li&gt;
&lt;li&gt;分析截屏，得到起跳位置和平台目标位置。&lt;/li&gt;
&lt;li&gt;通过某种公式计算得到按压时间&lt;/li&gt;
&lt;li&gt;使用WDA接口完成按压动作来实现跳跃。&lt;/li&gt;
&lt;li&gt;…重复…&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路很简单。讲一点实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分析起跳位置：因为我们控制的&lt;del&gt;”小棒“&lt;/del&gt;（误）基本由紫色构成，而图中别的元素并没有有紫色，所以可以通过过滤得到图中所有紫色色值区间内的点坐标来取一个平均值，得到它的基本位置，结果表示比较理想，基本每次都是同一个位置能够定位到起跳点。&lt;/li&gt;
&lt;li&gt;平台落点位置：最佳的目标点最好落在平台的正中央，我使用的方法比较取巧，首先得到背景颜色的色值区间，这样就可以判断当前坐标点是否是背景，然后开始在起跳点左上或右上的一个区域内从上往下从左往右地遍历，得到第一个非背景的坐标点。本想以此为目标点的横坐标，但是是实验过程中发现因为有圆形平台和图像中物体边缘会出现色值不稳定的情况，这样会大大影响到取点的精度。所以我在得到第一个非背景色的点坐标之后，再从该点的横坐标最右端向左遍历，找到第一个非背景色的点，然后两点取中点，这样得到的点就不会被圆形平台所影响了。然后开始取纵坐标，首先取得前一步得到的中点位置稍微下面一点的坐标点的色值（这么做的目前是为了避开边缘不稳定色值的区域），这个色值就是平台顶部的一部分颜色。然后拿这个色值在中点的纵坐标从上往下遍历，找到最远的一个同色值得点坐标，原因是因为大部分平台顶部的图像是对称的，所以不论刚才取到的色值是否是顶部的主要颜色，其另一段都会有一个颜色与之对应，这样两点取中点就得到了顶部的中点（该方法在音响平台的时候会失效，因为音响平台顶部图案是不规则的，但是因为跳一跳有反作弊手段，连续跳到中心点过多就会被系统判定作弊，所以遇到音响平台跳不到中心正好避免了反作弊措施…）&lt;/li&gt;
&lt;li&gt;计算按压时间：首先算得两个点距离d，我们可以猜到，这个距离一定和按压时间存在某种关系，那么是什么关系呢，这个让我研究了好一阵。网上有很多文章都写的是线性关系，也就是 &lt;code class=&quot;language-text&quot;&gt;y = kx + b&lt;/code&gt; ，但是我实践了很多次之后无论如何都无法计算出一个合理的k值。多次试验表明情况似乎不是这样。按压时间和距离的关系更接近于一个指数关系，于是我开始用 &lt;code class=&quot;language-text&quot;&gt;y = kx^2 + b&lt;/code&gt; 的公式来套实验数据，计算得到k，b值之后再实践，发现这样更为合理，继续实验的结果表明指数关系近更似于真实情况。&lt;/li&gt;
&lt;li&gt;不同设备参数各异：关于参数的问题是肯定的，不同的设备因为分辨率不同，跳跃参数也不尽相同，由于我手头设备有限，目前只实验得到了iphone7和iPhoneX的参数（后续大概率会继续更新不同设备的参数，所以强烈欢迎同学们算出自己设备参数之后共同维护项目）&lt;/li&gt;
&lt;li&gt;接下来就是重复的过程，不过中间会停留一段时间，一为跳跃完全落下，二为得到魔方井盖等停留加分平台的分数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;使用说明&lt;/h2&gt;
&lt;h3&gt;需要环境&lt;/h3&gt;
&lt;p&gt;(括号里是我使用的版本, 别的版本未经实验不保证成功, 机型: Iphone7)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nodejs (v9.3.0)&lt;/li&gt;
&lt;li&gt;NPM (v5.5.1)&lt;/li&gt;
&lt;li&gt;xcode (v9.2)&lt;/li&gt;
&lt;li&gt;WebDriverAgent&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;准备步骤&lt;/h3&gt;
&lt;p&gt;前两个就不说了，安装Node和NPM推荐使用&lt;a href=&quot;https://github.com/creationix/nvm&quot;&gt;NVM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/WebDriverAgent&quot;&gt;WebDriverAgent&lt;/a&gt;是Facebook出的一套iOS的WebDriver工具, 简单来说可以实时把连接的iOS设备状态模拟到一个Web服务器上, 提供一系列调试接口. 更多信息可以在项目主页里看到, 安装过程为:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;克隆到本地&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; clone https://github.com/facebook/WebDriverAgent.git&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入文件夹运行脚本&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;./Scripts/bootstrap.sh&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;脚本运行需要&lt;a href=&quot;https://github.com/Carthage/Carthage&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Carthage&lt;/code&gt;&lt;/a&gt;和&lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;, 这两个都是用来安装WDA的依赖包的, 看样子是依赖了node和iOS两种生态, 分别负责原生和Web两个模块, 安装&lt;code class=&quot;language-text&quot;&gt;carthage&lt;/code&gt;直接 &lt;code class=&quot;language-text&quot;&gt;brew install carthage&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;用Xcode打开文件夹里的 &lt;code class=&quot;language-text&quot;&gt;WebDriverAgent.xcodeproj&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是真机调试, 连接iOS设备后需要iOS开发者签名, 这一部分不做说明, 跟正常iOS开发一样, 需要注意的是, 要对项目内&lt;code class=&quot;language-text&quot;&gt;WebDriverAgentLib&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;WebDriverRunner&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;integrationApp&lt;/code&gt;都需填入开发者签名. 提供一个很好的中文参考文档&lt;a href=&quot;https://testerhome.com/topics/7220&quot;&gt;iOS 真机如何安装 WebDriverAgent&lt;/a&gt;. 还有就是国行的iOS设备需要端口转发才能访问, 需要将手机的端口转发到Mac上. 使用工具&lt;code class=&quot;language-text&quot;&gt;imobiledevice&lt;/code&gt;即可:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$ brew &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; libimobiledevice
$ iproxy &lt;span class=&quot;token number&quot;&gt;8100&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;8100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行WDA的test: [Product] -&gt; [test], 或者&lt;code class=&quot;language-text&quot;&gt;CMD + U&lt;/code&gt;. 之后iOS设备会安装一个WebDriverAgent App, 自动打开黑屏然后自动退出, 期间不用管它, 如果迟迟不退出, 有可能是失败了, 断开设备重连再运行test(还是失败可以删除App再试一试). 在App退出之后就可以正确运行js脚本了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后在项目根目录安装npm依赖(单独目录clone本项目, 和WDA结构上是独立分开的…), 运行:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;npm&lt;/span&gt; i&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;运行脚本&lt;/h3&gt;
&lt;p&gt;WDA启动之后, 可以尝试打开&lt;code class=&quot;language-text&quot;&gt;http://127.0.0.1:8100/status&lt;/code&gt;查看设备状态, 正常情况会有JSON返回, 打开&lt;code class=&quot;language-text&quot;&gt;http://127.0.0.1:8100/inspector&lt;/code&gt; 能看到这样：&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/371358516a4155f6b3f29d19ddf5c9a2/d5ef8/inspec.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACR0lEQVQ4y42STW/TQBCG81d7qRB/AAlRCami3LiAhEQFF3KjFQdE1aZAGlBpIaVtQkyS2nGcL8dO7NhOHH/bL7tubLlRghhpNJq159l3ZyYXBAHCMIRlWWA5DpIkkTyCT86Tb/Ss1+uB53m0Wi1omoYoAnzfJzGCrutgWRadTge5gBTQQ/qR/izLMqiFi3Nqkiyh2+2CIxfSQgqkRi+kRoGNRgOCICCnGCYUfQbPD5FYtIj0Elrsum5anFhILosWnrWcMAFaKsArIbhxAF6NUB/M8butwfYijEYyFEWJC6nqRHkWls1zPxojlKoi6nIEZujjjxSi2nNwJZiw3CjWK4rDWOVy8UpgrW/jqmOBEX3UqA88Ej0CD2A6t8+0HQfDoYRlywLTJzOk+LrnodJ3SXRQHfhgyFxongDpBtBJ0+bTnhqGEfc0yqhLgdc9Gz+FOX4RlRUxwDmr4eCUwQXJZ4lC2yYKhzHYNM04z27BXWDfQbnr4rLv4bDMY+vxNu7f28Rufg9zj/5Md9QmfRQxmUxiGJaU3QGW2wb2ixVsbT/H63cFPH32Ak92dvD++DtMMhRVGZMnTtO9WzeUFPgqv48HDx9hc2MDL3ff4JQzUCRNPBcsTG0f4mAARVVXDmQl8OhSwNuDM+T3PqBwweErN8U3bobSjQ6DAB3bgkOmvAqyEnjWNnHCEb8xUGKnOGlqKDYncdQtb+2KrAWWmiqOamN8aaj4XFeIq6nrc++fkJXATzUZHysyjhkFBQIuMOPbSFzLAP9X4V/1QXASkaJa+AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;inspec&quot;
        title=&quot;inspec&quot;
        src=&quot;/static/371358516a4155f6b3f29d19ddf5c9a2/fcda8/inspec.png&quot;
        srcset=&quot;/static/371358516a4155f6b3f29d19ddf5c9a2/12f09/inspec.png 148w,
/static/371358516a4155f6b3f29d19ddf5c9a2/e4a3f/inspec.png 295w,
/static/371358516a4155f6b3f29d19ddf5c9a2/fcda8/inspec.png 590w,
/static/371358516a4155f6b3f29d19ddf5c9a2/efc66/inspec.png 885w,
/static/371358516a4155f6b3f29d19ddf5c9a2/c83ae/inspec.png 1180w,
/static/371358516a4155f6b3f29d19ddf5c9a2/d5ef8/inspec.png 2462w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其他API看&lt;a href=&quot;https://github.com/facebook/WebDriverAgent/wiki/Queries&quot;&gt;这里&lt;/a&gt;, 其实这里的Wiki也不全, 我看过WDA源码之后找到这个&lt;a href=&quot;https://github.com/facebook/WebDriverAgent/blob/master/WebDriverAgentLib/Commands/FBElementCommands.m#L60&quot;&gt;文件&lt;/a&gt;, 里面应该是完整的API代码, 比较语义化, 应该能看得懂(主要会用到&lt;code class=&quot;language-text&quot;&gt;screenshot&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;touchAndHold&lt;/code&gt;的API).&lt;/p&gt;
&lt;p&gt;一切正常之后, 打开微信跳一跳, 开始游戏后在本项目根目录运行&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm start&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;为了更利于分析图像，我先对图像进行了一个劣化处理，以方便更好的划分边缘，(Ps: 欢迎和我谈论改进, 乐趣在开发过程, 所以我自己也就最多几千分就没挂着了, 不知道后面几万分会怎么样…先写这么多,  欢迎提issue或直接找我.)&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/bb6f44fa707fcbbb77fc1269d41aebec/41099/demo.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 45.94594594594595%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMEBf/EABYBAQEBAAAAAAAAAAAAAAAAAAMBAv/aAAwDAQACEAMQAAAB7cqxO6Qmf//EABgQAQEAAwAAAAAAAAAAAAAAAAExABAR/9oACAEBAAEFAm9wjon/xAAVEQEBAAAAAAAAAAAAAAAAAAAQQf/aAAgBAwEBPwGH/8QAFhEAAwAAAAAAAAAAAAAAAAAAARAx/9oACAECAQE/ARV//8QAFxABAAMAAAAAAAAAAAAAAAAAEAAhgf/aAAgBAQAGPwKW6f/EABoQAAIDAQEAAAAAAAAAAAAAAAAxASFRQYH/2gAIAQEAAT8hkYrxeix/TAo//9oADAMBAAIAAwAAABDsH//EABYRAQEBAAAAAAAAAAAAAAAAAAABQf/aAAgBAwEBPxC4R//EABYRAAMAAAAAAAAAAAAAAAAAAAEQIf/aAAgBAgEBPxA6X//EAB0QAAIBBAMAAAAAAAAAAAAAAAERABAhMXFBYfD/2gAIAQEAAT8QUQViMuJIhagbMcQ2RLqYdIfGjTf/2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;demo&quot;
        title=&quot;demo&quot;
        src=&quot;/static/bb6f44fa707fcbbb77fc1269d41aebec/41099/demo.jpg&quot;
        srcset=&quot;/static/bb6f44fa707fcbbb77fc1269d41aebec/a80bd/demo.jpg 148w,
/static/bb6f44fa707fcbbb77fc1269d41aebec/1c91a/demo.jpg 295w,
/static/bb6f44fa707fcbbb77fc1269d41aebec/41099/demo.jpg 500w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;关于不同设备的参数&lt;/h3&gt;
&lt;p&gt;参数在配置文件 &lt;code class=&quot;language-text&quot;&gt;/config.json&lt;/code&gt; 中配置&lt;/p&gt;
&lt;p&gt;我使用的iphone7, 也是配置文件中默认参数, 欢迎其他设备的同学提供对应的设备参数(PR, issue均可).&lt;/p&gt;
&lt;ul&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; checked disabled&gt; iPhoneX&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; checked disabled&gt; iPhone7&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; checked disabled&gt; iPhoneSE&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; iPhone7P&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; iPhone6P&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; iPhone8&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; iPhone8P&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[美餐机器人]]></title><description><![CDATA[在开始今天的”故事“前，先跟大家特别是据说在西溪园区有四五个食堂的幸福人群来科普一下： 美餐App。一个服务于阿里部分没有食堂的BU的神奇外卖App，主要任务是每天能够定时定点的投喂外卖给加班的程序猿，而美餐的订餐最后截止时间在每天的下午…]]></description><link>https://lqs469.github.io/订餐的烦恼/</link><guid isPermaLink="false">https://lqs469.github.io/订餐的烦恼/</guid><pubDate>Wed, 22 Nov 2017 16:34:10 GMT</pubDate><content:encoded>&lt;p&gt;在开始今天的”故事“前，先跟大家特别是据说在西溪园区有四五个食堂的幸福人群来科普一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;美餐App。一个服务于阿里部分没有食堂的BU的神奇外卖App，主要任务是每天能够定时定点的投喂外卖给加班的程序猿，而美餐的订餐最后截止时间在每天的下午5点准时停止。所以如果你错过了投食的申请时间，那么抱歉，对于没有时间出去吃一顿的加班汪来说，你就要饿肚子了…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b01df5aefb62e8041b5c7fa772192815/0b533/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 72.97297297297297%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAABjklEQVQoz61Ty07DMBDsb3PiVMGf8BHcWyQkBJyohARSm8p52Y5fazsvJg5qqUQOSIw2jrOe2bE3ySqE4Eg7UjG2MXTe+5AQQyRviZxSqiiKqq7KstRaIxkCzZxVjNFYpbTUtkEYY5qm0UY754gsecJanjNWZGVRolASfxuscHlP1ngmdky8GU2cc+gh7rq+SxjGoR+7YRj6vsfYtu3ZmWgS6ASTMG2PaBzHuq7zPAcHVCiRgRjl5tOtUAYmYMBNStkkYIIkqCiEOajQL4uLXGslpJCTEBDWWlBRCOYg/O6MHpMLZcF146ZQhFE1FklQeQJks/OQ8NO5l4a9Z9sjfz1Uzxl/QRzqJ24+krOEGEpscHYGzuK+G/dic7+7emS3m/16m60fjjeb7Hon78DDG2aMoXmLDbNWH46ftSgQXJZcVjXPtWlAFULMvTw5X555QmuNmz4qnyJELCE5d3t+bWD/IsaF5/Ev+Cdx2rU3TuBGZJyaJg5fNZmlmhfirmspWGjwu3g/T7BGSzs6ib8Aq7RhfwArqPIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;1&quot;
        title=&quot;1&quot;
        src=&quot;/static/b01df5aefb62e8041b5c7fa772192815/0b533/1.png&quot;
        srcset=&quot;/static/b01df5aefb62e8041b5c7fa772192815/12f09/1.png 148w,
/static/b01df5aefb62e8041b5c7fa772192815/e4a3f/1.png 295w,
/static/b01df5aefb62e8041b5c7fa772192815/0b533/1.png 500w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;什么 ？又过了订餐时间 ? …&lt;/p&gt;
&lt;p&gt;”啪啪啪…“，在一阵急促的键盘敲击声中，时间不知不觉已经到了4点60分，忙碌的程序猿小哥已经坐在显示器前超过3个小时了，办公室又热又闷，可以明显觉察到空气是不流通的，电脑的风扇散热提醒他应该调整一下姿势，于是他决定起来走一走，站起身，突然他觉得身体有点异样，饿了…&lt;/p&gt;
&lt;p&gt;一看表，已经是4点61分。完蛋，又完美地错过了5点的订餐时间… 看来今天的晚餐注定又要凑合挨饿了。哎，要是有一个提醒我及时订饭的服务就好了，闹钟？不不，那么low的东西怎么能彰显我的geek精神呢。对，为了能按时喂饱自己就做一个钉钉机器人吧，不不，只做一个机器人怎么够，既然要做就做个全套的，再研究一下美餐的订餐数据，找到最好吃的最受欢迎的套餐，恩，听起来不错，就这样，动手~&lt;/p&gt;
&lt;h3&gt;抓抓数据&lt;/h3&gt;
&lt;p&gt;美餐的数据是个很蛋疼的问题，因为美餐并不是一个2C的应用，它是企业直接对接美餐应用然后员工就有权限去浏览餐厅的信息，所以在网上直接爬数据的传统方法就行不通了。后来我通过App抓包的方法，发现使用自己的独立账号可以抓到所有高德（应该是自己BU都使用同一个权限）员工有权限订餐的餐厅数据，整理了一下接口之后总结出了从餐厅选择到订餐流程的各个接口的意义，（中间还意外的发现了原来美餐还提供了一个&lt;a href=&quot;https://meican.com/preorder/static/group&quot;&gt;web端&lt;/a&gt;入口…）。很好，这样就可以直接拿官方数据开始做数据的收集工作了。&lt;/p&gt;
&lt;p&gt;订餐的第一步，也就是选择可选订餐地点，这个跟员工的BU有关，我也只能看到高德员工可选的地点，得到的数据格式是这样（去掉了一些无关的数据）：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// API: https://meican.com/preorder/data/group?x={ userId }&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	groups&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; title&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;首开&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ... &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
 		&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; title&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;方恒国际&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ... &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
		...
	&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;选择地点之后接着要选择订餐时间点，每个时间点的餐厅会有不同，并且带着当前时间是否可订的状态（这个状态也是我们做订餐机器人判断是否可订餐的重要依据，字段&lt;code class=&quot;language-text&quot;&gt;status&lt;/code&gt;），接口数据如下（去掉了一些无关数据）：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// API: https://meican.com/preorder/api/v2.1/calendarItems/list？beginDate=2017-11-1&amp;amp;endDate=2017-11-8&amp;amp;withOrderDetail=false)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 默认会得到一周的可订餐信息，所以会有开始时间和结束时间&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	dateList&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
			calendarItemList&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
				&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
					openingTime&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
						closeTime&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;16:30&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
						...
					&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
					title&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;高德地图（首开外卖）晚餐1&quot;&lt;/span&gt;
					status&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;NOT_YET&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;					
					...
				&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
				...
			&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
		...
	&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	...
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从接口数据还可以知道订餐截止的时间，那么就可以根据这个做出最晚订餐时间的安排计划，比如我希望能在截止时间前30分钟提醒我。&lt;/p&gt;
&lt;p&gt;继续选择我们想要的时间地点组合，例如上面的 “18：30  高德地图（首开外卖）晚餐1”，就会得到所有可选店铺的列表：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// API: https://meican.com/preorder/api/v2.1/restaurants/list?&amp;amp;tabUniqueId=ff4df9a0-9851-4205-adae-b154cc05d811&amp;amp;targetTime=2017-11-01+16:30&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	restaurantList&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
			availableDishCount&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
			dishLimit&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
			latitude&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;39.991464&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
			longitude&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;116.396763&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
			name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;宅食送(UBP店)&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
			...
		&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
		...
	&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回数据里不光有店铺信息和地理位置，居然还有可以总订餐量（dishLimit）和当前可订量（availableDishCount），这就十分贴心了，这个数据就可以用来分析餐厅受欢迎的情况。&lt;/p&gt;
&lt;h3&gt;发发推送&lt;/h3&gt;
&lt;p&gt;我们已经得到了数据，那么就需要完成计划的第一步，做一个钉钉机器人来告诉我“该订餐了”。步骤如图所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开钉钉的聊天窗口，找到机器人&lt;/li&gt;
&lt;li&gt;直接添加机器人，然后选择自定义机器人&lt;/li&gt;
&lt;li&gt;然后下一步，最后会给你一个webhook，那个就是用来发送推送的hook&lt;/li&gt;
&lt;li&gt;然后只需要在代码里合适的时机post这个webhook 就可以触发机器人在当前聊天群里的动作了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/9d00a3eaf5e5c95a6a7f53f9371cb66d/0b533/2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 103.37837837837837%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAADCElEQVQ4y3VU207jMBTs/38T0kqrlWD3BYGWwpZCaZu0SXO1nauTMjvHaXpR4WHiY8cez7l50rYtmqrCzcMrZn4EY0rk+hqK6xnHbVogVBXC9RbBwkOYKhSFQdtaNE2DiRC2dYVfzx+Y+yG0NsjUCbkqkGTqON8mGmFOUu4NVlvs0hxlUcAJE0L5ONJCw2gFledQaoDmPEkSLJdLt66VgiG0/DPaYVA3kMk4GSY1dBzD9j26fg/b9USHbr+H4e0pycSWNbd+2Of+G3MkO7pc0ygZR7QNLG8Nlh9Yv73hYzbD8vUV/mLhxtV8jtXKRx4n3EdlvExR8QWhfORG7/kZj3d/oDKDJMrR091ODeipsJdRa+xNgT2JPssSPcOhwwCNtdTSnBN2WE+neLi9g85ypEmGigQ1Cbq6xp6u9by0F3fpRUdvOiHYhch9/5KwbQej4K2lBJ03mu0Wmsg8D8lmg4BIGeM8iqB3O/7bQHNN4m7OMnyZ5RFU0TIpcquhkoTEwcsLGh5WVOzUUK3bJ7aQnZ2fiNRR7oj2kCSJ4+Ptb9z8+AmwVlWwRfXN/ubkcnvxc1DcoGLsGiqKmeG15wOdhWIIKlFytf8bly1d6AgZZV2zNMoshfFJFASsgMy5Zw+ujuM5x1GhtI9iDaY6d0TFocZilobHTOa0ZS7rI6SoK4bmQqFMStaUYQ+nhcJa7ZBxlLUjeFgOin1OKPOcNXrVKcXZAeldUZLRvYiZFcREkqZOuTTB2ILi8lWnjIRClvHQjrGSB2DDBHirFdZ8GEZ7s/aONVkwYTVFfKmwZkalxlKWRbZ4g/ZWiN/nSN/fEM7+wXv66+bRfOaQco9iv2t2iqj+MsvWFahFYQHdArGxiHSDtOyx4aOqGiBvPgmO9SeSsoOq7HCuGXCRZam9ou7w9LrGdPaOMEqx5MsSJTkzrdyrLfaIut3z5bbupbpSeCzmtsf9yxL30wUSygyzCptIw9+pwY7NARqJ6bBT9iJ+Zwrb02K3dygqJqu2KAWNPdmHuakk9pfqxP4PpEhLSmPrZokAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;2&quot;
        title=&quot;2&quot;
        src=&quot;/static/9d00a3eaf5e5c95a6a7f53f9371cb66d/0b533/2.png&quot;
        srcset=&quot;/static/9d00a3eaf5e5c95a6a7f53f9371cb66d/12f09/2.png 148w,
/static/9d00a3eaf5e5c95a6a7f53f9371cb66d/e4a3f/2.png 295w,
/static/9d00a3eaf5e5c95a6a7f53f9371cb66d/0b533/2.png 500w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;推送格式有个很好的功能就是支持markdown，这样就可以很方便的组织内容。更加详细的推送内容格式和方法参考这里的官方文档&lt;a href=&quot;https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.karFPe&amp;#x26;treeId=257&amp;#x26;articleId=105735&amp;#x26;docType=1&quot;&gt;钉钉开放平台 - 文档中心&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我选用NodeJS来做推送服务，首先是抓取数据，做过滤，格式转换，然后当 ”status“值为“AVAILABLE”且当前时间比结束时间早3个小时的时候通知我，代码会隔一分钟访问一次接口，这样就不会在同一分钟内通知我两遍，这样推送的代码就完成了。另外我还在推送内容里加上一张来自&lt;code class=&quot;language-text&quot;&gt;lorempixel.com&lt;/code&gt;的随机美图来促进我的食欲。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a5712efaa549b7c9f6fb74b6c3d4f984/0b533/3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 57.432432432432435%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABp0lEQVQoz2P4+vHj/Dn9BobC1lYyFmbS/o7abalu1dFWxvoi8nKckhKsh48e+f///7eff378/o+GGIAS+3csSwtUKE4wiHRXMlPkz/fQPDEltyfP08tKPNpH8cL5E2DNf7Fr3rdrRXaCdk2hbUa0vqIgq6uOxNrqoJlZLlH2UqkRKpcunsSnedfOFcrKXFLSvEZ64g7aomKsDCXu6lvq/SIClYM8pC+cP45T87///0+fOpibHers4uzs6lJRkJAdH9SaG7d6YkVTbXJzbfKt2zf+/v///Rc2zT///P/249ebN69fvHj+8cMHoFlAACT//oeCX3/+Y2qDagZRv/48evjo+fMXjx8/fvHixaNHjz59+vT927evX79+//79BzY7ETZ//PT18uXLt27dunbt2vMXIPDhw4fPYADS//MvPpu///gN1Hnv3r27d+88ffL46ZMnnz5+BOr88uXLv3//fv7+h0/zrz9ANf/+/v375cefd19/f/rx58OXX5++/vj16ydQkIDmH7///fr199fvf99+/vv68//Xn/++/wLJ/f7z/xdIJ07NAJRHHLSIt0DXAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;3&quot;
        title=&quot;3&quot;
        src=&quot;/static/a5712efaa549b7c9f6fb74b6c3d4f984/0b533/3.png&quot;
        srcset=&quot;/static/a5712efaa549b7c9f6fb74b6c3d4f984/12f09/3.png 148w,
/static/a5712efaa549b7c9f6fb74b6c3d4f984/e4a3f/3.png 295w,
/static/a5712efaa549b7c9f6fb74b6c3d4f984/0b533/3.png 500w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后把工程放入Docker里，每天在后台跑着，通过机器人定时推送给我消息，就再也不用担心错过订餐啦~&lt;/p&gt;
&lt;h3&gt;终极问题——吃什么？&lt;/h3&gt;
&lt;p&gt;吾日三省吾身，早中晚餐该吃啥。对于有选择恐惧症的我来说，每天在思考吃什么这个终极哲学问题上浪费了大量的时间，而且在美餐App上并没有图示和评价，所以这大概是一次基于个人经验和口口相传的盲选… 为了解决这个问题，我们抓到的数据不正好派上用场嘛，于是我把所有时间点的所有店铺的数据都抓下来看看。&lt;/p&gt;
&lt;h3&gt;看看数据&lt;/h3&gt;
&lt;p&gt;然而真实情况是数据量并不大，（这也是内部订餐的局限，没办法像饿了么美团外卖一样去爬到大量数据，不过那些外卖平台也没办法得到实际卖出的情况），我尝试过抓取几个月前半年以前的数据，但是发现美餐好像定期的删除之前的数据，所有的数据大概只会保存一个月左右的。&lt;/p&gt;
&lt;p&gt;全部出现过的店铺数据：&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f5942573ebd119b9f37731a135afec2e/4971b/DDE43401-A029-4CFE-A246-9ECFD3FA9EB1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 40.54054054054054%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtklEQVQoz02R3W/TMBTF+///ByBWtodJSDwC6xASA+2hmsSmNW2yxGkcO4nznTjN1rI2SIcb7wOebN3re+7vHE+mswQn5xIfLxTefJI4/lbh9IfG0XlO9QgnX1O8P5OYzhTencV4+znCEc1M6X48i8w5/SLw4aLA6fcCkyCM8evGwnx+jaXtIxAKaaGh+0c47hpxWoGtJdVaJGmNptsio76IMjBfIFal6a9shiBMMFFJjOVigdvrG5R5jvu+w6bT+DMcIHiApq4QSYFOt6a+f/yNh/seRZ5BxbHpJ5EEX/sosgwTKSSclQ0ecBqMkFNRa43D4QDmechpiRTC1Oq6xna7NfdUKQiaLYoCIedgroskJsIkjuDYNi5/XmJxuyBRSQMdhlGQeSirCiKUaNsWTdO8CmZpaiDKsjTnmvlQicJEhCFW1hJLy8JI2xBF27TPhK4hECERkqBuNXa7HTabjSHkRDb2eRAQofdP0CbLoz3HduAS+rh1v9/DZ+zZsjRUL4Rd1z0JBvzVsvciGFGgFn3K1fwKd/YdSnrQ9z2GYUBCHzbmFvInwv8tj1mPmVcmkpCAmFnyF2suQyQwNuDQAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;DDE43401 A029 4CFE A246 9ECFD3FA9EB1&quot;
        title=&quot;DDE43401 A029 4CFE A246 9ECFD3FA9EB1&quot;
        src=&quot;/static/f5942573ebd119b9f37731a135afec2e/fcda8/DDE43401-A029-4CFE-A246-9ECFD3FA9EB1.png&quot;
        srcset=&quot;/static/f5942573ebd119b9f37731a135afec2e/12f09/DDE43401-A029-4CFE-A246-9ECFD3FA9EB1.png 148w,
/static/f5942573ebd119b9f37731a135afec2e/e4a3f/DDE43401-A029-4CFE-A246-9ECFD3FA9EB1.png 295w,
/static/f5942573ebd119b9f37731a135afec2e/fcda8/DDE43401-A029-4CFE-A246-9ECFD3FA9EB1.png 590w,
/static/f5942573ebd119b9f37731a135afec2e/4971b/DDE43401-A029-4CFE-A246-9ECFD3FA9EB1.png 784w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;高德望京周围店铺地理位置图：&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/bf6b98cb148e668e1b3daff521b49a1f/8bb81/749E6AD5-7507-4136-B9C0-4997234B6C03.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 69.5945945945946%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB6klEQVQ4y1VTWXakMAzkGJlAN4sXjDcg/fI397+WopJbhHz4CYQolUrlLqdE53GQsQst00jJOko5U+L8/eTUcjFufCJt2yYHz8htW4ud956WxdC6Oj4r7VxwxnSBZo751gAAKTUw1DewTWLODNgKkhRN00RoEEKQIo167vkYg0TnvOS0iQDmnPglkLVWGNSriY6bpHgcRzLGsDyWns8H5xrDUtq4ITDgPM+iHwAV4ECTlP5omUu5GGb+PvQDOW/o2H91FQ2XZWHaRkZVzeKlVYvIHfwdmoHdyQsyTGRdLdUab8uJ1IEZRnbOCQMd8fV6ScG3Fs8LFTDEhvmEsNLqHes+ynQXYK1ZPkK/9NYKca9VmGJssJJxwZ5/8gwE/eCOtiD8E8U6nTEz9X1PlsXWEeObBSxUOVe3Nv5/bJjHDsFdVlJPAlAYWmsEcHyO727x0rJwYeH3g59Pzn2x6Y+90PF1kizTmOufZqeVunF8yghYiuqoLHVksAW42zzVkmnn538fH4SFol63Dz07sBuGnjfm2U9FirDN+4bhr8CaFfFrA5+ZHQigVh0Cn3ZABqjQX/3VUf2ndzRn3iwkgHbYMt+qYRikFk3V+HJTcOUej4cAg6ne33YNwSz+uTVobj8/aRpgbkfxbS0A/gAtRZq1xWTgEgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;749E6AD5 7507 4136 B9C0 4997234B6C03&quot;
        title=&quot;749E6AD5 7507 4136 B9C0 4997234B6C03&quot;
        src=&quot;/static/bf6b98cb148e668e1b3daff521b49a1f/fcda8/749E6AD5-7507-4136-B9C0-4997234B6C03.png&quot;
        srcset=&quot;/static/bf6b98cb148e668e1b3daff521b49a1f/12f09/749E6AD5-7507-4136-B9C0-4997234B6C03.png 148w,
/static/bf6b98cb148e668e1b3daff521b49a1f/e4a3f/749E6AD5-7507-4136-B9C0-4997234B6C03.png 295w,
/static/bf6b98cb148e668e1b3daff521b49a1f/fcda8/749E6AD5-7507-4136-B9C0-4997234B6C03.png 590w,
/static/bf6b98cb148e668e1b3daff521b49a1f/efc66/749E6AD5-7507-4136-B9C0-4997234B6C03.png 885w,
/static/bf6b98cb148e668e1b3daff521b49a1f/c83ae/749E6AD5-7507-4136-B9C0-4997234B6C03.png 1180w,
/static/bf6b98cb148e668e1b3daff521b49a1f/8bb81/749E6AD5-7507-4136-B9C0-4997234B6C03.png 1602w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以看到店铺大致都是分布在公司的周围，毕竟太远的也不会承接这么大规模的送餐。
有一个比较好玩的是有一个很奇葩的店铺开在黄海上，恩… 这一定是个脏数据…&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/c36b55ee2c2cb979a6f561ca18e1a2b0/0d98f/AFAC8BC9-008E-4097-8D44-08942DFDE6C8.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 42.567567567567565%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXElEQVQoz2WRy07DMBBF8w+t7SRuqzwc6kdeDV2wQEgICdjx/19zmXHiQmExmqZyjs+9yZxz8DQPIeBjueBt6NF5h+A9PE0ItGlCH+KM44Ce9vF4hFLqNlJKFEWBLAHPdOiVDr84i84x0EUYg3l6upD3NI2YxhF5nkMIcQPy76qqkHl60bnVyLINGfIFjsDW2mg0L9N6Zgxo2wYlmfy1OxwOMVGWYiWbx2WJFvM8wVuH/itg+Bzg3z3cs0PZlhA78Q9YliWMMVvkrS/uxtpzBF6vS4yta43a1GiWBrrXkEpCyQ0m7/ur6xrZcpmjTYxEPa17NW7bFlKsALmjbRTyLofi/37ZcZ/GtFEmYxvuiWHJNHV6Op3uild7MnmiyFUOuZd3wDTxoyQjhjGcL+Fn/jBa6/gSj+CuCoUuPvMlP6Ycmc9kKyzczBIwdcubozdNE405rmbgZpeAbMf7G2wo/KxqpYAWAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;AFAC8BC9 008E 4097 8D44 08942DFDE6C8&quot;
        title=&quot;AFAC8BC9 008E 4097 8D44 08942DFDE6C8&quot;
        src=&quot;/static/c36b55ee2c2cb979a6f561ca18e1a2b0/fcda8/AFAC8BC9-008E-4097-8D44-08942DFDE6C8.png&quot;
        srcset=&quot;/static/c36b55ee2c2cb979a6f561ca18e1a2b0/12f09/AFAC8BC9-008E-4097-8D44-08942DFDE6C8.png 148w,
/static/c36b55ee2c2cb979a6f561ca18e1a2b0/e4a3f/AFAC8BC9-008E-4097-8D44-08942DFDE6C8.png 295w,
/static/c36b55ee2c2cb979a6f561ca18e1a2b0/fcda8/AFAC8BC9-008E-4097-8D44-08942DFDE6C8.png 590w,
/static/c36b55ee2c2cb979a6f561ca18e1a2b0/efc66/AFAC8BC9-008E-4097-8D44-08942DFDE6C8.png 885w,
/static/c36b55ee2c2cb979a6f561ca18e1a2b0/c83ae/AFAC8BC9-008E-4097-8D44-08942DFDE6C8.png 1180w,
/static/c36b55ee2c2cb979a6f561ca18e1a2b0/0d98f/AFAC8BC9-008E-4097-8D44-08942DFDE6C8.png 1276w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;得到数据之后，我们先来计算::每日总订餐率::，取了60天的数据，去除了一些干扰数据之后，用当天所有实际餐厅订餐数除以餐厅可订总数，得到每日总订餐数（r为出现餐厅数量，order为该餐厅订餐数，dish为该餐厅可订总量）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/80661bde2bab76ac6a84b2c7aa7cfa88/gif1.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样可以反映出当天的总体订餐情况，可以看到起数据还是有明显起伏的。然后我检查了他们对应的时间，其中10-29日达到了100%订餐，也就是所有店铺的餐全部订光了，检查了一下数据，发现那一天只有一家店铺在提供晚饭，所以被订光也是可以理解的了。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/4f1a9e79e542802a870b6a7799a1a757/b04e4/53EC41A0-2753-4FDA-8B7B-C383DA2400AF.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 43.24324324324324%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA40lEQVQoz4VRiw7EIAjz///25mNTUa4lapzJ5ZZ0KtRS0N33rc/zaO9dW2u2LvA8Y2Nttb55xx2n43sJDWI70MGrIajQAPYrvom6nLOmlEz0lWSRHXQnouXzMdFV+DDjKlpgy8vlEBAU4sUa4QhjMXcxWssCA60UK04OC03h5ZAEAbnicrkurSmqHDHCWkUsw2nx3tovwRuXueWwATYfXN4rTteM7Y9BocXbZuwKlPnSeszrL37wnKAKBVmB+xMzvudP7jybIH8Rw6ZoQMts32M288z5Mk9wf2GOzHFljByCe35fex7Fon0a44gAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;53EC41A0 2753 4FDA 8B7B C383DA2400AF&quot;
        title=&quot;53EC41A0 2753 4FDA 8B7B C383DA2400AF&quot;
        src=&quot;/static/4f1a9e79e542802a870b6a7799a1a757/fcda8/53EC41A0-2753-4FDA-8B7B-C383DA2400AF.png&quot;
        srcset=&quot;/static/4f1a9e79e542802a870b6a7799a1a757/12f09/53EC41A0-2753-4FDA-8B7B-C383DA2400AF.png 148w,
/static/4f1a9e79e542802a870b6a7799a1a757/e4a3f/53EC41A0-2753-4FDA-8B7B-C383DA2400AF.png 295w,
/static/4f1a9e79e542802a870b6a7799a1a757/fcda8/53EC41A0-2753-4FDA-8B7B-C383DA2400AF.png 590w,
/static/4f1a9e79e542802a870b6a7799a1a757/efc66/53EC41A0-2753-4FDA-8B7B-C383DA2400AF.png 885w,
/static/4f1a9e79e542802a870b6a7799a1a757/b04e4/53EC41A0-2753-4FDA-8B7B-C383DA2400AF.png 888w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;之后计算餐厅的::平均订餐率::（虽然餐厅数据量级比较小，但订餐率也能在某种程度上反映餐厅的订餐实际情况，也不失为一种判断标准），具体来说就是将餐厅出现天数中的订餐量之和除以可订餐总量之和，餐厅订餐率如下：（days为出现天数，order为订餐数，dish为可订总量）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/ce7cb862e78b15b72e6adf7881c3c8bf/gif.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;这也就侧面反映了餐厅的受欢迎程度。计算后发现近60天的订餐率最高的是金百万，有87.7%的订餐率，成为最受大家欢迎的店铺，其次是丽华快餐，订餐率达到87.1%，第三名是小芝麻。而最不受欢迎的店铺果然是兰州牛肉拉面，订餐率只有12.3%，这也挺符合大家平时的口评…&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0ae615ea1b60da0a5470261f0334ffa6/4b446/51E15540-5B67-4332-9169-BB79D4F49ED5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 45.94594594594595%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAACIUlEQVQoz1WSy08TURTG+Y/c+V+4aGIMbtzKwmiMYmJ0IcaqkZUBA0jQiDFqBImJGBQsbyzIQHlMUUpfdNryaGfaUjqdmc78vL1TFk5yZs4537nf/e6dr03TNNLpNJZl4XngWnU825b5f08T81wZngCb0WiI2vV8EL/XdjZv1+twlIP0HlZ0U47UayamaWI4ZRzXOVvXyt3WPh6O48rwCcWrWj2VUPLnDLHwmsj94a3fEdSNDQb091hC9bapotk5iR1ZDosru7i1KskMLIT93aTC4lGJ6c87TD97ztzwCGt1X3VMiTC3vkSPPizrr7UJbqYukzejLFccOm4N0f3tLjPKKeMTTcKGT3iYLfKxZ5XI2A8GbvTQNZMhFNsjNBvhoTJI0BgiG8vyMvqK9sQ5rqsX6Y2Xudf1jvb+AMHuFF19CaLafkthrsRg7wIfRl4TDDymc2ybjjdvefJphaDaR6faT++FL9ye7ORK9jxXtwI8+mNw5/4wl14EeBBMc+2pSnj3r09onpgsrm4zEQmhTK0yryYJKWssb+7yKyHquMLSqDj+zjzfU6NMxcZFX2NuYZ1J5Tuz83FmwwmKlYpPmM/nyQq5+UwOx3PEnR6QjMfJpFNoqQy5fY3j0qHINQpZHc+CasngpFLGKBgcHGhY9aq857ZarYau68KHNrZjC8CiVC5zXCjIb7FYlH1P+E03dN8yLec1ves0HOlF+Y+FY/4BOGmBgGHYhIUAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;51E15540 5B67 4332 9169 BB79D4F49ED5&quot;
        title=&quot;51E15540 5B67 4332 9169 BB79D4F49ED5&quot;
        src=&quot;/static/0ae615ea1b60da0a5470261f0334ffa6/fcda8/51E15540-5B67-4332-9169-BB79D4F49ED5.png&quot;
        srcset=&quot;/static/0ae615ea1b60da0a5470261f0334ffa6/12f09/51E15540-5B67-4332-9169-BB79D4F49ED5.png 148w,
/static/0ae615ea1b60da0a5470261f0334ffa6/e4a3f/51E15540-5B67-4332-9169-BB79D4F49ED5.png 295w,
/static/0ae615ea1b60da0a5470261f0334ffa6/fcda8/51E15540-5B67-4332-9169-BB79D4F49ED5.png 590w,
/static/0ae615ea1b60da0a5470261f0334ffa6/4b446/51E15540-5B67-4332-9169-BB79D4F49ED5.png 877w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过这样就找到公司附近这段时间最优质的外卖，对于我这种选择恐惧症来说，大大缩短了选择的时间，还可以定期的看一看最近的店铺情况，会第一时间发现有新的店铺加入，这样就在订餐的时候，掌握更多更好的信息。比较遗憾的是，美餐并不提供每个餐厅里菜品的订餐数据，不然我们就可以根据这个选择最受欢迎的菜品。&lt;/p&gt;
&lt;h3&gt;写在最后&lt;/h3&gt;
&lt;p&gt;作者因为实际需求的关系所以只做了美餐的数据爬取和分析，希望本文能够抛砖引玉，有兴趣的同学也可以对饿了么美团外卖这些外卖平台做一些数据的挖掘分析，拯救每天思考吃什么的终极哲学问题。&lt;/p&gt;
&lt;p&gt;最后附上&lt;a href=&quot;https://github.com/lqs469/meicanRobot&quot;&gt;代码&lt;/a&gt;，欢迎大家和我交流。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React 16.0新特性探究]]></title><description><![CDATA[在前段时间沸沸扬扬的的证书风波终以 facebook 的妥协告终之后，Facebook团队马不停蹄的推出了 Recat 的v16.0版本，先不说证书这个事件怎么看，关注 React 的同学们都知道，v16.0绝对是一次大变化，底层源码重构，发布新的 Fiber…]]></description><link>https://lqs469.github.io/Reactv16-0新特性探究/</link><guid isPermaLink="false">https://lqs469.github.io/Reactv16-0新特性探究/</guid><pubDate>Wed, 25 Oct 2017 17:33:16 GMT</pubDate><content:encoded>&lt;p&gt;在前段时间沸沸扬扬的的证书风波终以 facebook 的妥协告终之后，Facebook团队马不停蹄的推出了 Recat 的v16.0版本，先不说证书这个事件怎么看，关注 React 的同学们都知道，v16.0绝对是一次大变化，底层源码重构，发布新的 Fiber 核心算法，加入一系列呼唤许久的新特性，渲染性能优化，文件大小减少等等。那么下面就详细说说。&lt;/p&gt;
&lt;h2&gt;新的核心算法 Fiber&lt;/h2&gt;
&lt;p&gt;早在2015年的时候，fb官方就放出消息和文章，要着手开发新的底层算法框架去支持 React 的更新换代。终于在经历2年多的开发之后，这次新版本最重要的更新，就是这个名为 &lt;a href=&quot;https://www.youtube.com/watch?v=aV1271hd9ew&quot;&gt;Fiber&lt;/a&gt; 的核心底层算法，全新算法将改变 React 组件原有的渲染方式，不仅如此，Fiber 几乎是重写了整个 React 框架，以支持一系列的新特性和性能提高。在新的基础算法的支持下，React 变得更为强大也更有潜力。那么在 React 中是怎么做到的呢？那就要先说一说这个 Fiber。&lt;/p&gt;
&lt;p&gt;fb团队从开始设计 Fiber 时，就把它当做是 React 框架在未来发展的基础结构。Fiber 对框架的渲染和任务调度都有新的设计和实现，以实现在正确时的时间里做正确的事的目标，并对框架的积极响应能力做了很大的提升。一个有很多组件和复杂结构的SPA渲染起来有可能会变得很慢，Fiber 能够优先处理重要元素的渲染（加入了优先级制度），并且显著提高了渲染的速度，通过这种任务调度的能力使应用程序变得更好。&lt;/p&gt;
&lt;p&gt;而 Fiber 最为激动人心的地方就是实现了&lt;strong&gt;异步渲染&lt;/strong&gt;。一种通过对浏览器周期性地执行调度的方法来协调渲染工作的策略，在这一新特性的支持下，React 的渲染能够避免阻塞主线程，应用也可以更快的响应交互（然而在v16中，默认并没有开启异步渲染 …）。&lt;/p&gt;
&lt;p&gt;要理解 Fiber 的工作过程，首先来看一下 React 实现渲染的过程。在 React 中主要有两个部分去执行他们对应的过程：Reconciler 和 Renderer，可以理解为前者任务是渲染之前的 diff 算法等一系列过程，而后者的任务就是 React 对于不用平台（DOM，Canvas，Native…）的渲染执行过程。这两部分的分离意味着不同的渲染引擎能共享 React核心提供的协调算法，而使用它们各自的渲染器，这样可以更好做到算法优化的最大化。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 581px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/bff5ebc77ea50ac8f6079716541835ce/92d15/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 50.67567567567568%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABU0lEQVQoz4WSiW7CMBBE+/9/V1VVVYoEIYedhITciXMw3TExggJqpFEse/1mvPZbpCNQoQqhY4UkUUhThWOqodZ5VxOvaxRrb9ec3ubzDOqMBbpqsU1LbJIC70GGajB2nuvTMsPLa3yqEz7C3Na6tVvdAcveICxbhEWDXVZjmCeZvWxaRGnT43Bq4ItohldAbmICCoKmnDv/3TQiKGoxazAuF5N2HO8M74Cw6QaoqrnCDnkFZ+aKazMirjp4kj5re5hXQAJ6SUEIC48iHltLIm7Iuh65iD0MitYemwFo/tf0emTG9wQYnC7usTT9Zx9hnIxdb4yRHnb4jivsswaFABniaULbQ/kndSdqwa+UpvsqhTEDzDJbWC3QbprshRBIk6fA25s+r/BlHbsL6wXERBzTOJJ2lMPwCFTyQP+TlgcdyqPdeAd87TxsfR+JPPw40Q+1v4y9BAwtzo4BAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;1&quot;
        title=&quot;1&quot;
        src=&quot;/static/bff5ebc77ea50ac8f6079716541835ce/92d15/1.png&quot;
        srcset=&quot;/static/bff5ebc77ea50ac8f6079716541835ce/12f09/1.png 148w,
/static/bff5ebc77ea50ac8f6079716541835ce/e4a3f/1.png 295w,
/static/bff5ebc77ea50ac8f6079716541835ce/92d15/1.png 581w&quot;
        sizes=&quot;(max-width: 581px) 100vw, 581px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;
（Reconciler 和 Renderer。图为React Conf 2017上，Lin Clark做的A Cartoon Intro to Fiber分享的ppt视频。）&lt;/p&gt;
&lt;p&gt;每当组件触发更新或者渲染、卸载时，Reconciler 会对组件的状态与新状态进行 diff 算法，比如执行&lt;code class=&quot;language-text&quot;&gt;setState()&lt;/code&gt; 时，Reconciler在一系列相关逻辑执行完毕之后，将会在组建中触发 &lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt;去渲染或者更新 React 节点的元素。在老版本中，Reconciler 的整体调度方式叫做 Stack Reconciler ，他会独立维护一个所有组件组成的“实例”树，它包含所有用户和框架所定义的组件，而用户无法访问到这个实例树并且不会对外暴露。而在v16中，这个 stack 换成了这次的主角 Fiber，叫做 Fiber Reconciler。新的 Fiber Reconciler 算法意在解决原来有一些积压已久的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以中断且分离任务为多个“帧”&lt;/li&gt;
&lt;li&gt;可以在执行中制定优先权，重新制定和重新执行任务&lt;/li&gt;
&lt;li&gt;可以在父节点与子节点之间来回切换以支持react的渲染&lt;/li&gt;
&lt;li&gt;可以让 &lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt; 返回多元素&lt;/li&gt;
&lt;li&gt;最好支持&lt;code class=&quot;language-text&quot;&gt;error boundaries&lt;/code&gt;（下文会介绍到）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在原来的调度算法实现中，会递归调用组件实例树，每一个更新都是立即执行，由于浏览器JS单线程的原因，整个更新渲染过程会同步进行，这样其实也是比较合理的方案，因为渲染本来就不需要等待IO，只是单纯去执行浏览器计算即可，但是当组件的复杂程度越来越大之后，浏览器的计算不足以应付繁重的任务，于是就开始排队，而且这个排队过程中会占住浏览器主线程，使用户的操作完全被阻塞，没有响应，造成很差的用户体验。这个问题在复杂组件的场景会很常见，那么首先要明白问题的关键，在与用户的交互中，界面是没有必要每一个更新的都立即执行的，这样的做法中无用的开销会很高；另外，不同类型的组件之间有相对的重要程度，有的需要马上与用户交互，有的则不会被重视到，那么就要引入优先级的概念来安排渲染顺序。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/2d6f76460c4b1a47889899f09977f130/0a47e/2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 32.43243243243243%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDklEQVQY011Qy07DMBDM//8BJ058ARdQ1UqlQuoBkJCQgEJCVYpE86JJEydZ2xl2HZdG2JrsZndmPXYQVw2mrzEUGRQNMTSK1sPl5HP6y0sPqZWe22gDyzsAeszeEtxv9tw0iA+EpCKk9T+Masf+oTPIlXZQpE8Dy45w855ClrYWureOUI/QGuOi0poVvXP0+LXnYR0f0LIZ4ioPlE9NhKvnHS6fvvHwWTCxZFKHjF0IckUI09rFKFO4uNtiuf7B2e3axUWUY1soiLnA9MPd5UeKUVZhzm4n/K6LMMM8TFmQ4Xy5wWyV4PolxnQV4yOv2LV2OrBejMmswPpEM4bmsHp3zGnDXXQQjjmiPUJ4v4oyy9vgDiFvAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;2&quot;
        title=&quot;2&quot;
        src=&quot;/static/2d6f76460c4b1a47889899f09977f130/fcda8/2.png&quot;
        srcset=&quot;/static/2d6f76460c4b1a47889899f09977f130/12f09/2.png 148w,
/static/2d6f76460c4b1a47889899f09977f130/e4a3f/2.png 295w,
/static/2d6f76460c4b1a47889899f09977f130/fcda8/2.png 590w,
/static/2d6f76460c4b1a47889899f09977f130/0a47e/2.png 600w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;
（图为“一调到底”的调用栈执行方式，主线程一直被占用，来自Lin Clark做的A Cartoon Intro to Fiber分享的ppt视频）&lt;/p&gt;
&lt;p&gt;首先，我们都知道 React 组件实质是一个函数，只要是一样的输入，就会得到同样的输出组件。而浏览器跟踪程序执行的方式是调用栈，不断的入栈与出栈来实现组件的渲染过程。但是问题就是，如果我们只依赖调用栈去执行程序，我们就只能老老实实等待它变空，无法提升什么效率了。那么我们要做的工作就是去自定义调用栈，或者操作调用栈。而这就是 Fiber 的设计目的，实现 React 组件的堆栈操作，按照你想要的方式和时机去执行，一个虚拟的堆栈结构。&lt;/p&gt;
&lt;p&gt;从 Fiber 的设计思想来说，Fiber 是一个基于组件的执行单元，多个 Fiber 可能对应于同一个组件，你可以对它暂停，继续，修改优先级等操作。在对 Fiber 的调度过程中，为了实现及时的 “打断” 和 “继续”，我们把调度过程分为两个阶段，第一阶段叫做 Render /Reconcilication  Phase 过程，用于建立Fiber树，任务树，并且得到需要改变的节点表，但是此时并不会开始执行改变，第二阶段叫做 Commit  Phase 过程，用于执行DOM上的上述改变。在第一阶段中，执行过程是可以被随时打断，所以我们可以要求主线程在正确的时机放下手中的任务去执行更优先的任务，但是第二阶段的渲染过程不可以被打断，一旦启动就会执行到结束。&lt;/p&gt;
&lt;p&gt;新的结构中，更新执行的过程被被切分成了很多“帧”，每一帧的时间很短，在每一帧执行一小段任务，在每一小段任务执行完毕之后 Fiber 就会检查调度任务的模块，看是否有别的优先级更高的任务需要执行，这样唯一的主线程就不会被长时间占用，其他任务就有机会被执行。维护每一帧的执行与切换，就是 React Fiber 算法。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/2944689de58540873e661adbc35689d2/0a47e/3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 43.91891891891892%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABUUlEQVQoz41RaU/CQBDl//8WUUBALKiJH4zRRJRLMAYxBnpBibFCuz2eM9NdPBKj3bzu25nZN7MzpTRPkdECIdf4yfFPO2uVWExlKYJNjE2S4F0lCGMlu+HmvNuV+mYPNhHdVSJaYlXG9fMah30HjYGDas9GXXO2dcY+TiY+cRtNstVolxji1r2Hi+kKb3FcCCZUHX+zIMRed47K3UJwQOBLjaGD9tijiy5qvUKIfeXuAk3ysW1ov5JCjoSfzD8+TJehBHJAa+Si0ltIJcckxJWxICfiBCZRa1RUezULREN6mIpgBi+MpMIqCR1RYPl2Lgnq/aIiSwtzMokhwX0dc/m0+qzQTHmbJtQTG6cPHs4I1tilp7rCOxMX549L6tWSeukR92Vv65ibl7W0jdsnU870yFk0IsTkiDRXXzhjq/0mxviNxm7KjBzZnyv/xWY0PgC3/aDR1es35AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;3&quot;
        title=&quot;3&quot;
        src=&quot;/static/2944689de58540873e661adbc35689d2/fcda8/3.png&quot;
        srcset=&quot;/static/2944689de58540873e661adbc35689d2/12f09/3.png 148w,
/static/2944689de58540873e661adbc35689d2/e4a3f/3.png 295w,
/static/2944689de58540873e661adbc35689d2/fcda8/3.png 590w,
/static/2944689de58540873e661adbc35689d2/0a47e/3.png 600w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;
（任务分成多帧之后，中断任使得主线程可以得到处理另外的任务的机会，图来自Lin Clark做的A Cartoon Intro to Fiber分享的ppt视频）&lt;/p&gt;
&lt;p&gt;在每一帧的执行过程中，React 会去询问主线程是否有余下时间继续接下来的任务，如果有时间那么React就会开始执行任务，但是这样也就会出现一个问题，就是时间不够用的情况，任务没有完成，时间就到了，而此时有优先级更高的任务进来，把之前的任务打断，这时候优先级更高的任务会被主线程优先执行，而低优先级任务则会作废，在下一次有机会时再次被执行，这个就是第一阶段 Render /reconcilication  Phase 过程中被打断的情况。而整个一帧一帧不断切换、继续的执行过程，就叫做 work loop，这让 React 可以在它与主线程的来回切换之间做一些计算来提升交互。&lt;/p&gt;
&lt;p&gt;关于 Fiber 具体实现过程，我会专门写一篇关于 React Fiber 算法的源码分析，敬请期待…（大概可能也许吧）&lt;/p&gt;
&lt;h2&gt;灵活的 render 返回&lt;/h2&gt;
&lt;p&gt;在以往版本的 &lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt; 函数返回中，只能以完整的单个DOM返回，例如&lt;code class=&quot;language-text&quot;&gt;&amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt;&lt;/code&gt;如果只是想返回个简单的字符或者数组就得套上一层，这样套下来的结果就是整体结构跟俄罗斯套娃似的，一推无用的DOM结构，只是为了返回语法而存在，十分累赘且无效，更不用说性能消耗和可能潜在造成的css问题。
那么在新版本中，render不仅可以返回数组，还可以返回字符串或数字等。例如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;render() {
  // No need to wrap list items in an extra element!
  return [
    // Don&amp;#39;t forget the keys :)
    &amp;lt;li key=&amp;quot;A&amp;quot;&amp;gt;First item&amp;lt;/li&amp;gt;,
    &amp;lt;li key=&amp;quot;B&amp;quot;&amp;gt;Second item&amp;lt;/li&amp;gt;,
    &amp;lt;li key=&amp;quot;C&amp;quot;&amp;gt;Third item&amp;lt;/li&amp;gt;
  ];
}

render() {
  return &amp;#39;Look ma, no spans!&amp;#39;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体来说，在render函数执行时，可以有以下返回：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常规React节点：正常渲染JSX，原生DOM组件或者自定义高阶组件&lt;/li&gt;
&lt;li&gt;字符串或者数字：将会被当作文本节点加入DOM中&lt;/li&gt;
&lt;li&gt;Portal组件：这是一个react新加入的特性，会在下文详细介绍&lt;/li&gt;
&lt;li&gt;null：可以渲染null了&lt;/li&gt;
&lt;li&gt;布尔值：如果为布尔值则返回null，于是render可以这样写：&lt;code class=&quot;language-text&quot;&gt;return flag &amp;amp;&amp;amp; &amp;lt;div /&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数组：多个DOM以数组形式返回，如上例代码段。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在曾经的版本中如果没有返回一个符合规范的JSX，就会报错：“&lt;em&gt;A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object&lt;/em&gt;”（或者别的啥）。在原有的算法结构里并不支持多元素的返回结果，所以在老版本的&lt;code class=&quot;language-text&quot;&gt;react-dom.js&lt;/code&gt;的&lt;code class=&quot;language-text&quot;&gt;ReactCompositeComponent.mountComponent&lt;/code&gt;函数中对不合规定的返回结果做了报错处理。&lt;/p&gt;
&lt;p&gt;在经历了多个版本的“声讨”，终于不用在一层套一层的DOM了…  其实在几年前关于多子元素返回的&lt;a href=&quot;https://github.com/facebook/react/issues/2127&quot;&gt;争论&lt;/a&gt;就有很多，这样做也的确能让结构和语法更优美一些，fb的工程师也参与了很多的社区讨论，但是因为结构复杂的原因，在没有改变原有结构的情况下一直没有合适的解决方案。在“多方”的“讨论”之下，fb也终于决定开始着手支持这一特性&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/d4502ecaed8f9857d85cf19df4d6ca68/5b587/4.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 92.56756756756756%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC2klEQVQ4y3VUTW/aQBDN/7/13FuPldJGqtQolZool6KqX4dCsCGAjTFfxsYY4w/s9eubBQMJdKXRftj79s3Mm7mqVIWqqlBkGZIkge/78BYLBMulnhcLX5vnLbTNPQ/zuafPfD9AkqZQSmkTnCtwyEJGyo+dThe9Xh/dbg9PT20MBhYcZ4TRyIVLcxwHrjvGcOjoMwE+xbiSRb3RDGZzZHu2m03CRzIURYGyLPVcr+uhKoWS7GrQF4AOXxyS0XodY7WKEMexBk4InCQp9xv9iDwoVwSsHgeGp5uiVFjzUkSwMFwRdMV9jO12izzf7hmWep3lub5jrUcwwt45wwNLxss0O3h+7sEa2LBsW8dLziWetr2Lnewjsh58ucHz15s9oDoyrAEte4hms4V228TInmLGmI7HE824/ufUq96H73Buf+/OVHUOOJlMdab7ZCOM+v0BLMvWmZfsSlY3mw0Kui2j+eYjzLef94AXGIp7wtAwOmgbJlqtJ7rfJ7CF9pOh1wIsD6WM57zxgHHj/hjD14Cz2UxfEKZDak5mEbKIWLKsaolg9//t5hfe+XcHCZ0B2oyhQWaSGGEqe2EtbrvuRMdTEiPSkfGj8QmP366PSamBqr2mhJ2A9eiaaXZ1PCfTKZMSIorWtEhrtAbsmj/RNBrnLtdjShdFMhIjh8zGe/cXrOuQuowpekmKPKDyCg/GHa7/vj+6XIP5M5c/xoh4IViGWJGNlJ2iFBT/kfIS4R+MCZECjP60kLQ6L4Ut4/HLPWUyJIs1/CAkKCslivWc5QXyLStEKubUKJ2AbJNSXXZZSkwy6nneQW8ZWcosNZxkCptUIaWraVbxIQWd7JOkHkuPm5z1KfKQnrjrdz6W7ItBEHAm62BFD2J6sMIypCdhxiTFusYvdhuJmeO4rNXxQYtLltxp+9rNW5S6UShs9dl/2ldZJMgzdpd8zTlFljA+ZFcQpLxoBV43l39lxa1hky1K5wAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;4&quot;
        title=&quot;4&quot;
        src=&quot;/static/d4502ecaed8f9857d85cf19df4d6ca68/fcda8/4.png&quot;
        srcset=&quot;/static/d4502ecaed8f9857d85cf19df4d6ca68/12f09/4.png 148w,
/static/d4502ecaed8f9857d85cf19df4d6ca68/e4a3f/4.png 295w,
/static/d4502ecaed8f9857d85cf19df4d6ca68/fcda8/4.png 590w,
/static/d4502ecaed8f9857d85cf19df4d6ca68/efc66/4.png 885w,
/static/d4502ecaed8f9857d85cf19df4d6ca68/5b587/4.png 1010w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;
（图为 github 上对新版本要做的feature的讨论结果)&lt;/p&gt;
&lt;h2&gt;更好的错误处理&lt;/h2&gt;
&lt;p&gt;在以往的 React App 开发中，一遇到 React 的错误发生，将会是一片腥红的报错屏，页面停止工作，只能刷新恢复。现在不再会这样了。新版本使用了更为弹性的错误处理策略，如果在组件中存在渲染错误，那么整个组件树将不会从根节点被渲染出来，这样避免了错误数据的出现。&lt;/p&gt;
&lt;p&gt;除此之外，还引入了一种新的概念“Error Boundaries”，这是一种 React 组件用于捕捉子组件树中的 JavaScript 的错误，并且记录下来，还可以回调错误处理的逻辑，这样就不会任由React被报错停止工作了。Error Boundaries 在渲染时开始捕捉错误，以 &lt;code class=&quot;language-text&quot;&gt;componentDidCatch()&lt;/code&gt; 的方法调用 ，他将会以生命周期的情形加入组件中，完成 catch JS的报错，换句话说就是 React 版的 try catch。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;componentDidCatch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;error&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; info&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 处理错误&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; hasError&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 记录错误&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;logErrorToMyService&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; info&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;目前，只有Class组件可以使用&lt;code class=&quot;language-text&quot;&gt;componentDidCatch()&lt;/code&gt;，另外他只会 catch 它的树结构子节点的错误，这并不会包括它自己的。并且错误会传递到上层，这一点与 JavaScript 的 catch{} 类似。&lt;/p&gt;
&lt;p&gt;新的错误捕捉机制可以解决一系列问题，那些没有被捕捉到的错误将会使得子组件被停止渲染，这个在实际环境中会很有用，我们都不希望一个有错误的页面直接呈现到用户面前，这样可能会暴露很多问题，引起麻烦。那么使用 error boundaries ，即使出现错误，错误的组件停止渲染，其他功能依然可以正常交互。这样使得应用的健全性提升了一个档次，当然，建立完善的错误控制体系也是一个成熟应用应该具备的。&lt;/p&gt;
&lt;p&gt;其实在React v15中，fb团队写了一个不太完善的组件可以实现部分 &lt;code class=&quot;language-text&quot;&gt;componentDidCatch()&lt;/code&gt; 的工作，叫做&lt;code class=&quot;language-text&quot;&gt;unstable_handleError&lt;/code&gt;，（所以叫做 unstable），在新版本中，这个保留的方法将被放弃，转而使用更为高大上的 &lt;code class=&quot;language-text&quot;&gt;componentDidCatch()&lt;/code&gt; 。&lt;/p&gt;
&lt;h2&gt;Portals 组件&lt;/h2&gt;
&lt;p&gt;Portals 的作用就跟他的名字一样形象，（好像也没找到别的译名），这是一种新的 ReactDom 组件方法，&lt;strong&gt;能够渲染位于当前结构位置之外的组件&lt;/strong&gt;，这个需求也许这样听着不太明白，但是举个🌰就很清晰了，比如我们常用的提示框，会突出显示在屏幕中间那种，一般出现的时候会居中并且优先于别的操作页面，有的还会把背景加上阴影啥的，像这样的组件在常规的组件逻辑里，会直接写在当前的页面中，类似于：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; loading &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Loading &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再由当前的组件决定是否显示，先不说组件复用的问题，在这里 CSS 样式就有可能出现不稳定的情况，因为每个用到这种提示框的外部组件都可能不一样，再一个个调 position 啥的实在是太麻烦了，而且从结构上来看，这种交叉的结构实在是谈不上优美。那么，Portals 组件就出现了，其实他的作用就如其名，在组件中放一个“传送门”，让复用组件渲染的结果出现在你想要的地方。代码例子如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; ReactDOM&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createPortal&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;children&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    domNode&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过&lt;code class=&quot;language-text&quot;&gt;ReactDOM.createPortal()&lt;/code&gt;，你就可以把children插入到你希望出现的DOM节点处。&lt;/p&gt;
&lt;h3&gt;Portals的事件冒泡&lt;/h3&gt;
&lt;p&gt;Portals 组件与正常的 React Elements 并没有什么差异，包括事件的处理，所以无论逻辑上还是写法上 Portals 都是与当前组件是“一体”的。在事件冒泡传递中，Portal 内的事件依然会传递到外层，优美的实现了功能和逻辑。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div onClick&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;handleClick&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Modal&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Modal 是Portals组件&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Child &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Modal&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 点机 &amp;lt;Child /&gt; 会触发 this.handleClick()&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;尽管 Modal 和当前的组件并不在一个 DOMtree 上，但是依然会触发 &lt;code class=&quot;language-text&quot;&gt;handleClick&lt;/code&gt; 点击事件。&lt;/p&gt;
&lt;h2&gt;更好的服务端渲染&lt;/h2&gt;
&lt;p&gt;在新版本中，团队完全重写了服务端渲染，他变得更快并且支持字节流（Stream）传输。有关 Node 的 Stream 的请看&lt;a href=&quot;https://nodejs.org/api/stream.html#stream_readable_streams&quot;&gt;这里&lt;/a&gt;。Stream 是一种很好的建立于应用和服务之间传输的方式，使用它我们可以不用一次性读或写一个大文件，转而以字节流的形式传输文件，这样对于文件的传输时间和空间效率都有重大的作用。（另外，fb团队将原先大量的&lt;code class=&quot;language-text&quot;&gt;process.env.NODE_ENV&lt;/code&gt;检查减少到了一个，这是因为&lt;code class=&quot;language-text&quot;&gt;process.env&lt;/code&gt;并不是一个常规的 JavaScript 对象，读它很昂贵）。因此，开发环境中的性能将与生产环境相差无几，但错误处理和Portals组件（没有可绑的DOM节点…）暂时还没有加入 SSR。总体来说速度提升了一个台阶，比 v15 的时候快了近3倍（官方数据）。&lt;/p&gt;
&lt;p&gt;我们先来看看在React v15中的SSR是怎么做的。首先在服务端的框架里（Express，Koa）使用原来的方法&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;ReactDOMServer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;renderToString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;element&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 传入React element，返回为HTML String。可以用于请求的快速返回用于加载页面或者有利于PWA的SEO。&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 服务端或者浏览器都可以使用&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将React组件转为String，然后写入response中。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// using Express&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; renderToString &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;react-dom/server&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; App &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;./App&quot;&lt;/span&gt;
app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;req&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; res&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&amp;lt;!DOCTYPE html&gt;&amp;lt;html&gt;&amp;lt;body&gt;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&amp;lt;div id=&apos;content&apos;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;renderToString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;App &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&amp;lt;/div&gt;&amp;lt;/body&gt;&amp;lt;/html&gt;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在浏览器端，再使用&lt;code class=&quot;language-text&quot;&gt;render&lt;/code&gt;将HTML String渲染出来就完成了SSR。在v16中的服务端渲染过程中，以往的&lt;code class=&quot;language-text&quot;&gt;render&lt;/code&gt;方法换成了&lt;code class=&quot;language-text&quot;&gt;hydrate&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;ReactDOM&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hydrate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;element&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; container&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;callback&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;hydrate&lt;/code&gt;用于”注入“服务端渲染的HTML内容。因为这个版本是严格向后兼容的，所以原有的&lt;code class=&quot;language-text&quot;&gt;render&lt;/code&gt;方式也可以使用，这个保留会在v17去除。同时，在新版本中，对 HTML 的转换也变得更高效，老版本的 HTML 会对每个元素注入&lt;code class=&quot;language-text&quot;&gt;data-reactid&lt;/code&gt;，对文本注入&lt;code class=&quot;language-text&quot;&gt;react-text&lt;/code&gt;，他们只是单纯无聊的递增id而已。而新版&lt;strong&gt;能够&lt;/strong&gt;去除这些冗余的东西。大大减少了文件的体积。&lt;/p&gt;
&lt;h3&gt;支持 Stream&lt;/h3&gt;
&lt;p&gt;这是一个十分有用的新特性，SSR 支持 Node Stream 传输。Stream 可以减少内容的第一字节（TTFB）时间，同时在内容还没完全生成的时候就开始传输，浏览器会更快更早的开始渲染页面，用户体验也会更好。Stream 的另一个好处就是在阻塞时，能够更好的处理数据包堵塞的时候可能会发生的丢包，当阻塞时，渲染机制会得到信号并且触发 Node Stream 的方法将其转换到到 paused 模式，直到阻塞被清除，渲染机制又会接到信号再转换为flowing 模式继续传输。这意味着服务端可以使用更少的内存，保持更积极的响应 I/O。Stream 的渲染方法如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;ReactDOMNodeStream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;renderToNodeStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;element&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 返回 Readable stream 格式的 HTML String&lt;/span&gt;
ReactDOMNodeStream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;renderToStaticNodeStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;element&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 与 ReactDOMNodeStream.renderToNodeStream 类似，但是不会注入多余的DOM标签，比如`data-reactid`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种方法都只能在服务端使用，默认情况下会返回utf-8格式的字节流。&lt;/p&gt;
&lt;p&gt;当使用 &lt;code class=&quot;language-text&quot;&gt;renderTo(Static)NodeStream&lt;/code&gt; 去返回一个可读字节流时，Stream 会处于 Paused 模式，渲染也会暂停，只有当可读字节流对象触发 &lt;code class=&quot;language-text&quot;&gt;read&lt;/code&gt; 或者 &lt;code class=&quot;language-text&quot;&gt;pipe&lt;/code&gt; 方法时才会开始”flowing“字节流和渲染，比如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// using Express&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; stream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;renderToNodeStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;MyPage&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// paused 模式，并且停止渲染&lt;/span&gt;
  stream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;res&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; end&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// flowing 模式，开始渲染。&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 特别的是，参数`{ end: false }`表示是否在输入结束时停止，应当为false，否则渲染结束而响应未结束时会发生丢包&lt;/span&gt;
  stream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;end&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 完成，stream 结束&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而新版本的 Stream SSR 有一个问题需要注意，不要使用 JSX 嵌入 JavaScript 的写法，例如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;renderToStaticMarkup&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;renderToString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;App &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样在老版本 SSR 中没有什么错误，但是在 Stream 中会报错，因为&lt;code class=&quot;language-text&quot;&gt;renderToString()&lt;/code&gt;的返回是可读流格式，并不能当做元素嵌入到JSX之中。&lt;/p&gt;
&lt;h2&gt;支持自定义的DOM标签&lt;/h2&gt;
&lt;p&gt;以往React会忽略不认识的DOM标签，在很多时候就得写所谓的React标签白名单去支持逻辑或者第三方库，实在是辣鸡，没有什么比一个名如其实的标签更让人亲切了，不过起名字不是程序员最头痛的事吗？使用例子：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div mycustomattribute&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;something&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，如果遇到使用了DOM原有标准的标签的情况，React优先原有的标准标签，也就是说，如果你要是自定义了这类标签，那会无效的。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 没问题
&amp;lt;div tabIndex=&amp;quot;-1&amp;quot; /&amp;gt;

// Warning: Invalid DOM property `tabindex`. Did you mean `tabIndex`?
&amp;lt;div tabindex=&amp;quot;-1&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除此之外，&lt;code class=&quot;language-text&quot;&gt;data-&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;aria-&lt;/code&gt; 依然可以继续使用，这一点没有做改变。但是，React 也一直明确表示，数据不应该放在标签里来存放，毕竟有 state 或者 store 去管理数据，而在 v16中，会把传递的数据转为 String 再传过去，所以这样也可能会导致潜在的问题。&lt;/p&gt;
&lt;h2&gt;setState() 变聪明了&lt;/h2&gt;
&lt;p&gt;原来执行 &lt;code class=&quot;language-text&quot;&gt;setState()&lt;/code&gt; 无论如何都会重新渲染页面，而现在如果参数为 null，将不再触发渲染，这样就可以直接使用 setState 来决定是否重新渲染页面，这个小小的改变会对开发十分有用。&lt;/p&gt;
&lt;h2&gt;更轻薄&lt;/h2&gt;
&lt;p&gt;一个程序的优秀性在于其重构的次数 ，重写了底层算法之后，大小缩小了这么多：（官方数据）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;react is 5.3 kb (2.2 kb gzipped), 原来 20.7 kb (6.9 kb gzipped).&lt;/li&gt;
&lt;li&gt;react-dom is 103.7 kb (32.6 kb gzipped), 原来 141 kb (42.9 kb gzipped).&lt;/li&gt;
&lt;li&gt;react + react-dom is 109 kb (34.8 kb gzipped), 原来 161.7 kb (49.8 kb gzipped).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整体比之前的版本小了32%（压缩后小了30%）。体积的改变也部分归功于打包方式的改变，新版本使用了&lt;code class=&quot;language-text&quot;&gt;Rollup&lt;/code&gt;去打包成更为扁平的 bundles，结果也更让人欣喜。&lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup.js&lt;/a&gt;也是一种模块打包工具，类似于webpack，那么为啥要换成 Rollup 来打包呢，我们都知道 webpack2.0 加入了&lt;code class=&quot;language-text&quot;&gt;tree-shaking&lt;/code&gt;功能，其实这个功能的提出最早出现在 Rollup 中，Rollup 自称下一代的 JavaScript 模块化工具，使用 ES6 模块编写，支持很多新特性，可以编译成 UMD 或者 CommonJS 等格式。具体的特性可以参考官网的介绍，总结下来，应用开发的打包推荐使用Webpack，更全面也更强大，而到框架级别推荐使用Rollup，效率会更好。&lt;/p&gt;
&lt;h2&gt;MIT licensed&lt;/h2&gt;
&lt;p&gt;你问我支不支持，我当然是支持啦。
只是心疼那些迁移工程做了一半的同学们 …&lt;/p&gt;</content:encoded></item></channel></rss>