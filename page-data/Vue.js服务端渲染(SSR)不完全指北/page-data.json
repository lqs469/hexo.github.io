{"componentChunkName":"component---src-templates-blog-post-js","path":"/Vue.js服务端渲染(SSR)不完全指北/","result":{"data":{"site":{"siteMetadata":{"title":"lqs469","author":"Qinshuo(Allen) Li"}},"markdownRemark":{"id":"214ec0bc-8c43-5a22-a39b-ccf475fae5f0","excerpt":"What’s this? SSR(Server-Side Rendering) — 服务端渲染 服务端渲染是相对于客户端渲染而言的(Client Side Render), 它的渲染行为发生在服务器端, 渲染完成之后再将完整页面以HTML字符串的形式交给浏览器, 最后经过”注水”过程将一些事件绑定和Vue状态等注入到输出的静态的页面中, 由同步下发给浏览器的的Vue bundle…","html":"<h3>What’s this?</h3>\n<p><strong>SSR(Server-Side Rendering) — 服务端渲染</strong></p>\n<p>服务端渲染是相对于客户端渲染而言的(Client Side Render), 它的渲染行为发生在服务器端, 渲染完成之后再将完整页面以HTML字符串的形式交给浏览器, 最后经过”注水”<code class=\"language-text\">hydrate</code>过程将一些事件绑定和Vue状态等注入到输出的静态的页面中, 由同步下发给浏览器的的Vue bundle接管状态, 继续处理接下来的交互逻辑. 这也是一种同构应用的实现(代码可以运行在客户端和服务端中).</p>\n<h3>When SSR?</h3>\n<p>那么 <strong>什么情况下该使用SSR方案呢</strong> , 其实一句话总结下来就是展示型应用:</p>\n<ol>\n<li>对SEO有需求. CSR无法直接满足SEO, 他需要切换成SSR或者借助Prerendering方案. Prerendering: 一种在服务端使用无头浏览器渲染出页面, 再输出静态页面的解决方案, 也能实现SEO需求, 好处是比较简单(通过webpack插件就可以实现)可以保持前端模块不需要SSR改造, 但是性能比SSR差不少.</li>\n<li>对首屏渲染速度和性能有需求. 如果需要更早的将页面展现给用户而不是白屏的话, 最好的方案还是把渲染工作交给服务端, CSR(SPA)应用的更适合场景应该是中后台web应用, 一般有较多的交互逻辑和页面数据处理, 同时CSR会使用更多的内存, 对浏览器造成较大的压力.</li>\n<li>过多依赖客户端环境的场景. 直接将渲染工作全部交给客户端和JavaScript来处理其实对于web应用来说是很脆弱的, 浏览器的情况千差万别, 网络环境也是无法预测, 即使做了再多的兼容工作, 也无法保证任何情况下都能完美展示. 有时候即使框架本身也不足以(不愿意)支持所有情况.</li>\n<li>安全性考量. 对于有权限控制和内容限制的应用, 使用SPA的时候就要考虑很多安全性限制的问题, 对于应用结构的设计增加了不少复杂度.</li>\n</ol>\n<h3>Why SSR ?</h3>\n<p>在早期的web开发技术栈中, 实际上都是服务端渲染, 像是Java, PHP, ROR, ASP.NET. 当前端MVC出现之后, 浏览器端渲染模型开始出现并且流行 — “开局一块HTML模板, 元素全靠JS加载”. 这种方式带来了比较快速的页面切换体验和极好的开发效率, 以及丰富的技术生态.\n但是CSR也不是没有缺点, <strong>缺点很明显</strong>而且不改变其核心思路的话没办法克服:</p>\n<ol>\n<li>SEO不友好\n首先因为开局服务器丢给浏览器的是一块空白(有标记)的HTML模板和一坨打包好的JS代码, 所以做SEO时候普通的爬虫没办法实抓取到真实的web内容, 虽然现代爬虫号称已经能够处理CSR页面, 但是处理成本过高等问题还是让CSR的SEO结果不尽如人意.</li>\n<li>首屏加载速度\n同样因为浏览器会在接受到完整的一坨JS代码之后才能执行他, 导致了首屏加载经历了:\n解析HTML(渲染HTML模板) -> 获取JS -> 执行JS -> JS渲染页面 -> JS处理数据相关逻辑 -> 页面加载完成. 这样一个过程之后才能完整呈献给用户, 速度自然就下来了, 更不用说网络因素和客户端环境因素对体验的影响. 即使有前端缓存的存在, 但是页面渲染过程仍然不会轻松.</li>\n<li>鉴权等安全性功能实现起来较复杂\n其次, 因为是服务端一股脑把打包好的JS代码交给用户, 所以如果在应用中有鉴权的逻辑, 就会牵扯到鉴权逻辑的设计. 这时候就要前后端合作来保证安全性, 复杂度增加.</li>\n</ol>\n<p>其实在大多数场景下, 你都没必要使用SPA的方案(可以看看<a href=\"https://journal.plausible.io/you-probably-dont-need-a-single-page-app\">这篇文章</a> ). 那么既然某些场景下不适合使用CSR方案, 我们直接退回到以前的web开发方式就好了, 干嘛要去踩SSR新的坑呢?  那么<strong>对比传统的web应用, 使用框架SSR的好处</strong>有哪些呢:</p>\n<ol>\n<li>对比传统方式, 首先最大的好处当然就是技术栈生态, Vue, React等前端MVC给开发带来很大便利, 相应的生态也蓬勃发展, 配套的UI套件, 框架组件, 设计语言, API设计很多程度上已经改变了如今的开发方式. 换句话说, 使用jQuery纯手撸的人原来越少了.</li>\n<li>其次是同构带来的便利. 一套代码由两边的执行环境使用, 可以同时支持SSR和CSR的渲染, 当SSR失效的时候还可以降级为CSR, 或者当服务器压力过大的时候主动降级以增强鲁棒性.</li>\n<li>对技术人员的技术栈统一. SSR还是使用的前端工程师常规熟悉的技术栈, 没有过大的技术门槛, 也没有太多的技术债, 更适合项目的可持续维护和前端团队的技术发展.</li>\n</ol>\n<h3>构建逻辑</h3>\n<p>在Vue-SSR构建过程中, 会将代码打包分成两个部分: 服务端bundle; 客户端bundle.\nNode.js会处理服务端bundle用于SSR, 客户端bundle会在用户请求时和已经由SSR渲染出的页面一起返回给用户, 然后在浏览器执行”注水”(<code class=\"language-text\">hydrate</code>), 接管Vue接下来的业务逻辑. 这里就会有一个问题, 服务端是如何将store状态交给客户端的呢, 因为整个构建流程是彼此独立的, 数据预取(在进入渲染页面之前获取到页面所需要的数据)之后交给了store, 而注水过程怎么接收store数据? 其实中间有一个特殊的状态保存: <code class=\"language-text\">window.__INITIAL_STATE__</code>, 这个state会在服务端渲染执行<code class=\"language-text\">context.state = store.state;</code>的时候自动写入<code class=\"language-text\">window</code>中, 所以在客户端代码中就就可以直接通过<code class=\"language-text\">store.replaceState()</code>接收服务端预取的数据了.</p>\n<p>构建逻辑示意图很经典, 如下:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/15d4e944e835243e004ab08e46fa7cd3/99e81/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.94594594594595%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABeUlEQVQoz21SyU7DMBDNZ/MHSFw4ceBegeCAhDhw4oBUqRKIsldAW7pSt0mrNE2a1fZjPG66ICayPHZm3vi9GUdrDaUUSiuKAss4gbn/u4xt+1JKjt1kAw6DUUCaZrzMOcvynURzZ8/bgBqykFhES2RRiMyfQVEBBjSVfoQLMZmRv6nnBTHqbZcBNyxsEa8v0H9vsz8+Ocbb/h7icAFHU2ClJtD06U/nCkntCEpbOvMoRdcNWQalJHKpUdAyX0DFvZ5g+Pl9FdO7KiRhEaDE6yBEexjDb70jHb5w1afODG6Qsp8TIJXA+e0IN4+eEWHNwjxI0h4kklk4WpM+ucT1WQOXp01EsaUl/BjLVK4aZfd6o4fPzph9lygPGt/sJ80DpIOKbYoBTJIcH88TjIcBC2v10piShg+tCdO3zVstMl94GH11WZakfYhMXDB9p+zgmsJWd4M4Q8+LdpqiVzGlBYuQNS9z+YW207RLtU4ux2l3bP6fR23nif1fN6S3zbKq9eUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"SSR构建逻辑.png\"\n        title=\"SSR构建逻辑.png\"\n        src=\"/static/15d4e944e835243e004ab08e46fa7cd3/fcda8/1.png\"\n        srcset=\"/static/15d4e944e835243e004ab08e46fa7cd3/12f09/1.png 148w,\n/static/15d4e944e835243e004ab08e46fa7cd3/e4a3f/1.png 295w,\n/static/15d4e944e835243e004ab08e46fa7cd3/fcda8/1.png 590w,\n/static/15d4e944e835243e004ab08e46fa7cd3/efc66/1.png 885w,\n/static/15d4e944e835243e004ab08e46fa7cd3/c83ae/1.png 1180w,\n/static/15d4e944e835243e004ab08e46fa7cd3/99e81/1.png 1946w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>所以webpack需要两个入口(服务端, 客户端):</p>\n<p><strong>entry-client.js</strong>:\n客户端 entry 只需创建应用程序, 并且将其挂载到DOM, 然后将Store状态同步给客户端bundle：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> createApp <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../main'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span> app<span class=\"token punctuation\">,</span> store<span class=\"token punctuation\">,</span> router <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">createApp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 同步store</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>__INITIAL_STATE__<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  store<span class=\"token punctuation\">.</span><span class=\"token function\">replaceState</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>__INITIAL_STATE__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nrouter<span class=\"token punctuation\">.</span><span class=\"token function\">onReady</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\trouter<span class=\"token punctuation\">.</span><span class=\"token function\">beforeResolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">to<span class=\"token punctuation\">,</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> matched <span class=\"token operator\">=</span> router<span class=\"token punctuation\">.</span><span class=\"token function\">getMatchedComponents</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> prevMatched <span class=\"token operator\">=</span> router<span class=\"token punctuation\">.</span><span class=\"token function\">getMatchedComponents</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> diffed <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> activated <span class=\"token operator\">=</span> matched<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">c<span class=\"token punctuation\">,</span> i</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> diffed <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>diffed <span class=\"token operator\">=</span> prevMatched<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> asyncDataHooks <span class=\"token operator\">=</span> activated<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">c</span> <span class=\"token operator\">=></span> c<span class=\"token punctuation\">.</span>asyncData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">_</span> <span class=\"token operator\">=></span> _<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>asyncDataHooks<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span>asyncDataHooks<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">hook</span> <span class=\"token operator\">=></span> <span class=\"token function\">hook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> store<span class=\"token punctuation\">,</span> route<span class=\"token operator\">:</span> to <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'client entry asyncData function emit'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\tapp<span class=\"token punctuation\">.</span><span class=\"token function\">$mount</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#app'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><strong>entry-server.js</strong>:\n服务端入口需要处理路由, 并触发数据预取逻辑</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> createApp <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../main'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token parameter\">context</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span> app<span class=\"token punctuation\">,</span> router<span class=\"token punctuation\">,</span> store <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">createApp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    router<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t  router<span class=\"token punctuation\">.</span><span class=\"token function\">onReady</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> matchedComponents <span class=\"token operator\">=</span> router<span class=\"token punctuation\">.</span><span class=\"token function\">getMatchedComponents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// 对所有匹配的路由组件调用 `asyncData()`</span>\n      Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span>\n        matchedComponents<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">Component</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Component<span class=\"token punctuation\">.</span>asyncData<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> Component<span class=\"token punctuation\">.</span><span class=\"token function\">asyncData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> store<span class=\"token punctuation\">,</span> route<span class=\"token operator\">:</span> router<span class=\"token punctuation\">.</span>currentRoute <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          context<span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">;</span>\n          <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>app<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span>reject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>具体实现</h3>\n<!-- > VueSSR + Begg 的实现已经集成进了脚手架工具[K2](http://gitlab.alibaba-inc.com/qinshuo.lqs/k2)中.\n>\n> 感兴趣的同学可以尝试一下, 一键搭建, 即开即用😃 -->\n<p>明确了选型原因和框架特性, 我们就要开始着手搭建一个Vue-SSR框架, 推荐文档: 官方出品的SSR指南 <a href=\"https://ssr.vuejs.org/\">https://ssr.vuejs.org/</a> . 里面讲解了你所需要知道的全部名词解释和API介绍, 基本不需要再单独查资料了. 同时他给出了一个官方出品的 <a href=\"https://github.com/vuejs/vue-hackernews-2.0/\">Demo</a>, demo的作者就是尤雨溪, 你想要参考的内容里面也基本都实现了一遍, 不过这个Demo是基于Express的, 改造成Egg还需要一些工作. </p>\n<p>Vue-SSR + Egg.js, 在结构上跟普通的Vue服务端渲染也是一样的. 首次请求到达时, 由Egg.js处理, 在服务端执行渲染器逻辑并输出静态页面, 一共输出的还有客户端bundle, 然后客户端bundle接管应用, 继续接下来的任务, 变成一个”普通”的Vue应用. 同时Egg.js还会处理来自页面的异步请求, 处理正常服务端的工作. 下面是应用整体结构的示意:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c3b984632fc7471948f3d2a54f35bcac/92bb4/2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.35135135135135%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB70lEQVQoz21SzW7TQBDOI/B+3IEn4AmK1EOpeAAQ4oAqjsAJOFEEKqrKoUnkqDR1FRLspLZjr3e9v/bH7NqJemCk9e56dr75ZuYbdV2HFkBHq65rMCGA4e598Gs4d8PZG6d3SZKgLLe4byNnLdTyD9RqiarmSKIIfDKGmM9hjenBWrsH5mWJdLGAUQqGYhshoRoFrU1IOGqdQ372A/n3byEg//IZ2YvnyF+/Akv+Bvbe/K4JYHF8hN9PHpH/JepK4uriBle/YrCcE2BLDAlQ3MZYjy8pwECtE8hZBD2/hhQNLKeSLt/Dlim4cdhQouLwGcq3b8BZg/T2DmXGAkuPNfLZjXXIigLadHs2/kSFQow/oXv6APzsBHJoYcMl8rSiVUKrvi1t28JSBYGhDv2gptcRMZmS0/fNQWkLUxfA5CMc20AQC2MU7lY5Zuc3iMdL5JstxZrQ4sDQf5wvlRLx2RFWXx+CFTQgJsB5Deva/QT9W09dc4t8XdBAGop1kFIGn2c58jSds71s4ndg0wPIOglsvAJ8as92J5lSZlgU11C2CXdDSmCMBbAgm6BDuvgJFdstGElnp7vdox2Y6yxOJsc4PH2MKDsP/xJSQhzHqKqqB8R/7L6A94LuerlPNz9xGn9A3qTBr7WCIJGbQbP/AFZg+ZmFXsuzAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"SSR应用整体结构.png\"\n        title=\"SSR应用整体结构.png\"\n        src=\"/static/c3b984632fc7471948f3d2a54f35bcac/fcda8/2.png\"\n        srcset=\"/static/c3b984632fc7471948f3d2a54f35bcac/12f09/2.png 148w,\n/static/c3b984632fc7471948f3d2a54f35bcac/e4a3f/2.png 295w,\n/static/c3b984632fc7471948f3d2a54f35bcac/fcda8/2.png 590w,\n/static/c3b984632fc7471948f3d2a54f35bcac/efc66/2.png 885w,\n/static/c3b984632fc7471948f3d2a54f35bcac/c83ae/2.png 1180w,\n/static/c3b984632fc7471948f3d2a54f35bcac/92bb4/2.png 1824w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>具体来说, SSR的核心思路就是使用<code class=\"language-text\">vue-server-renderer</code>创建一个渲染器(renderer), 然后给这个渲染器传入Vue实例, 渲染器会得到HTML页面, 最后由Egg.js将HTML返回, 实现代码有些繁杂这里就不一一放出来了, 核心流程可以简化成:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 第 1 步：创建一个 Vue 实例</span>\n<span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> template<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>Hello World&lt;/div></span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 第 2 步：创建一个 renderer</span>\n<span class=\"token keyword\">const</span> renderer <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'vue-server-renderer'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">createRenderer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 第 3 步：将 Vue 实例渲染为 HTML</span>\n<span class=\"token keyword\">const</span> html <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> renderer<span class=\"token punctuation\">.</span><span class=\"token function\">renderToString</span><span class=\"token punctuation\">(</span>app<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 第 4 步, 返回 HTML</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>ctx<span class=\"token punctuation\">.</span>body <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>ctx<span class=\"token punctuation\">.</span><span class=\"token function\">renderString</span><span class=\"token punctuation\">(</span>html<span class=\"token punctuation\">)</span></code></pre></div>\n<p>具体的实现代码可以在k2搭建的SSR框架中的<code class=\"language-text\">app/controller/template.js</code>文件中找到.</p>\n<h3>开发环境</h3>\n<p>SSR + Egg 的生产实现并不难, 但是支持HMR的开发环境搭建就稍麻烦些, 主要是<code class=\"language-text\">devMiddleware</code>, <code class=\"language-text\">hotMiddleware</code>和Egg.js配合使用. 原理是使用这些开发中间件监听并构建Vue文件后放在内存中, 再响应用户的请求.</p>\n<p>具体来说, 在开发环境下, dev renderer中会执行dev-server并监听Vue代码, 当Vue代码发生变化时更新渲染renderer, 并返回给Egg, Egg会等待dev-server的返回后去执行输出. 因为egg的是基于koa, 所以dev Middleware简单封装一下直接挂载egg中的app上就可以, 具体实现代码可以查看k2搭建的SSR框架中的<code class=\"language-text\">build/setup-dev-server.js</code>文件.</p>\n<p>这里有个值得注意的地方就是<code class=\"language-text\">hotMiddleware</code>中间键在注册之后就会接管所有请求, 这时候本希望走到Egg的请求就会被指向Vue,  这是不希望看到的, 所以需要在<code class=\"language-text\">hotMiddleware</code>中过滤一下:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// setup-dev-server.js</span>\n<span class=\"token operator\">...</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">hotFn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ctx<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 过滤 HMR</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'webpack_hmr'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> stream <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PassThrough</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  ctx<span class=\"token punctuation\">.</span>body <span class=\"token operator\">=</span> stream<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token function\">hotMiddleware</span><span class=\"token punctuation\">(</span>\n    ctx<span class=\"token punctuation\">.</span>req<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token function-variable function\">end</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      write<span class=\"token operator\">:</span> stream<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>stream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token function-variable function\">writeHead</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">state<span class=\"token punctuation\">,</span> headers</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        ctx<span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> state<span class=\"token punctuation\">;</span>\n        ctx<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>headers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hotMiddleware headers'</span><span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> headers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    next\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>hotFn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">...</span></code></pre></div>\n<h3>SSR优化</h3>\n<p>通过服务端渲染, 我们将应用从IO密集型转为了CPU密集型, CPU的压力会在QPS爆发时剧增, 这时候就需要针对SSR进行一些优化, 常见的优化方式有:</p>\n<h4>缓存</h4>\n<p>一般分为页面级别缓存和组件级别缓存.</p>\n<ul>\n<li>\n<p>页面级别缓存: 对于相同的页面的请求, 其内容也相同(不考虑个性化页面情况), 所以将路由与对应页面缓存下来可以很有效命中缓存, 降低性能开销.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 使用 LRU </span>\n<span class=\"token keyword\">const</span> microCache <span class=\"token operator\">=</span> <span class=\"token constant\">LRU</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  max<span class=\"token operator\">:</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span>\n  maxAge<span class=\"token operator\">:</span> <span class=\"token number\">1000</span> <span class=\"token comment\">// 重要提示：条目在 1 秒后过期。</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token operator\">...</span>\n<span class=\"token comment\">// 命中缓存</span>\n<span class=\"token keyword\">const</span> hit <span class=\"token operator\">=</span> microCache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span>hit<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">...</span>\n\n<span class=\"token comment\">// 缓存下来</span>\nmicroCache<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">,</span> html<span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n<li>\n<p>组件级别缓存: 组件缓存在组件渲染过程进行命中判断, 所以会影响组件渲染结果, 所以要确保组件不依赖上下文状态且无副作用, 换句话说缓存的是不会改变内容的展示型组件. 实现方法是使用<code class=\"language-text\">vue-server-renderer</code>内置的组件级别缓存配置参数, 在创建 renderer 时传入. 更多参数可以参考 <a href=\"https://ssr.vuejs.org/zh/api/#cache\">具体缓存实现方式</a> .</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> renderer <span class=\"token operator\">=</span> <span class=\"token function\">createRenderer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  cache<span class=\"token operator\">:</span> <span class=\"token constant\">LRU</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    max<span class=\"token operator\">:</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">,</span>\n    maxAge<span class=\"token operator\">:</span> <span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n</ul>\n<h4>降级方案</h4>\n<p>核心思路就是当CPU使用率过高的时候即使切换到CSR模式.\n可以结合Egg提供的schedule能力, 在启动时执行一个定时任务, 监控CPU使用率, 当大于阈值时切换到CSR模式. 而Egg也提供了单核schedule能力, 这样可以将定时任务的性能损耗降到很小; 或者在渲染执行时计时, 如果超时则自动返回CSR bundle, 降级为CSR应用, 这样虽然能临时解决CPU高开销无法及时响应的问题, 但用户体验并没有什么实质性改良.</p>\n<h3>要注意的坑</h3>\n<p>Vue-SSR的坑还是不少的, 特别是和Egg.js结合时, 经过了一段比较蛋疼的踩坑阶段,  现在终于稳定下来支撑业务. 这里把开发期间<strong>遇到的问题</strong>总结一下:</p>\n<ol>\n<li>生命周期不同. 这个问题最为明显, 在CSR和SSR中生命周期钩子是不同的. SSR中只有<code class=\"language-text\">beforeCreate</code>和<code class=\"language-text\">created</code>会被执行. 而在CSR中所有周期都会再执行一遍. 另外需要注意的是, 在服务端代码中不要写有全局副作用的代码, 例如写了 <code class=\"language-text\">setInterval</code>而不清除它. 因为在SSR周期没有<code class=\"language-text\">beforeDestory</code>阶段, 所以以往CSR中销毁页面前清除副作用的方法就没法继续使用了, 而此时的<code class=\"language-text\">setInterval</code>就会被永远不会清除了!</li>\n<li>因为我们采用同构的目的是写一份尽量通用的代码, 让它运行在两端. 所以我们需要对不同端的运行环境特别熟悉才行, Node.js端是没有浏览器对象的, 所以<code class=\"language-text\">window</code>, <code class=\"language-text\">document</code>, DOM操作都没法执行. 同理, 浏览器端是没有<code class=\"language-text\">process</code>对象的. 他们各自的API实现也有差别, 这点需要特别留意. 比较麻烦的就是第三方库的引入, 有时候你并不知道引入的库能不能完全运行在Node端/浏览器端. 如果它只能运行在纯浏览器环境, 那可以在<code class=\"language-text\">created</code>阶段之后引入和执行来避开Node.js下执行.</li>\n<li>\n<p>避免单例. 在CSR中, 每次我们打开页面都是从服务端下载代码(或缓存), 然后创建一个全局的根Vue实例. 但在SSR中情况有所变化, 因为服务端会一直运行, 如果一直用同一个全局的Vue实例, 就会导致每次客户端的请求到指向了同一个根Vue实例, 就有可能造成状态污染. 所以这里要使用工厂函数在每次请求到来时, 新建一个Vue实例, 执行逻辑返回结果. 同样的, <code class=\"language-text\">Store</code>和<code class=\"language-text\">Router</code>也要这样处理:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// main.js</span>\n<span class=\"token keyword\">import</span> Vue <span class=\"token keyword\">from</span> <span class=\"token string\">'vue'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> App <span class=\"token keyword\">from</span> <span class=\"token string\">'./App.vue'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> createStore <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./store'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> createRouter <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./router'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">createApp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token function\">createStore</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> router <span class=\"token operator\">=</span> <span class=\"token function\">createRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    router<span class=\"token punctuation\">,</span>\n    store<span class=\"token punctuation\">,</span>\n    render<span class=\"token operator\">:</span> <span class=\"token operator\">/</span>h<span class=\"token operator\">/</span> <span class=\"token operator\">=></span> <span class=\"token function\">h</span><span class=\"token punctuation\">(</span>App<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> app<span class=\"token punctuation\">,</span> router<span class=\"token punctuation\">,</span> store <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// router.js</span>\n<span class=\"token keyword\">import</span> Vue <span class=\"token keyword\">from</span> <span class=\"token string\">'vue'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> Router <span class=\"token keyword\">from</span> <span class=\"token string\">'vue-router'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> Home <span class=\"token keyword\">from</span> <span class=\"token string\">'./views/Home'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> About <span class=\"token keyword\">from</span> <span class=\"token string\">'./views/About'</span><span class=\"token punctuation\">;</span>\n\nVue<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>Router<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">createRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Router</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    mode<span class=\"token operator\">:</span> <span class=\"token string\">'history'</span><span class=\"token punctuation\">,</span>\n    routes<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token punctuation\">{</span>\n        path<span class=\"token operator\">:</span> <span class=\"token string\">'/'</span><span class=\"token punctuation\">,</span>\n        component<span class=\"token operator\">:</span> Home<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">{</span>\n        path<span class=\"token operator\">:</span> <span class=\"token string\">'/about'</span><span class=\"token punctuation\">,</span>\n        component<span class=\"token operator\">:</span> About<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>数据预取问题. 在业务中经常会遇到需要我们输出的页面是带有动态数据的, 也就是在渲染页面的时候先异步取一次数据, 然后将返回的数据放入页面中, 最后输出给用户. 其实处理这个逻辑的原理很简单, 就是在服务端整个请求周期中预取数据再注入最后页面就行. 为了尽早的发出请求, 可以在路由模块中执行数据预取逻辑, 在实例化之前就执行异步请求, 然后放入<code class=\"language-text\">Vuex</code>, 然后交给Vue页面去渲染. 这块的代码比较分散, 可以<a href=\"https://ssr.vuejs.org/zh/guide/data.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%95%B0%E6%8D%AE%E9%A2%84%E5%8F%96-server-data-fetching\">看这里的实现</a></p>\n<p>值得注意的是使用<code class=\"language-text\">v-html</code>注入动态获取的HTML内容的时候. 如果HTML内容有<code class=\"language-text\">&lt;script&gt;</code>所包含的JS代码, 会发现<code class=\"language-text\">script</code>中的事件绑定失效. 其实在这里页面被渲染了两次, 第一次是发生在SSR直接交给浏览器的时候: 此时<code class=\"language-text\">&lt;script&gt;</code>完整被渲染在浏览器里, 其内容正常执行, 事件绑定也正常的绑定在了当时的DOM元素上. 而第二次渲染时, 走的是CSR: 在这时由于是以<code class=\"language-text\">v-html</code>的方式来渲染替换HTML, 但是<code class=\"language-text\">v-html</code>实质上是<code class=\"language-text\">innerHTML</code>操作, 这样\t<code class=\"language-text\">&lt;script&gt;</code>虽然会被替换上去, 但是其中的内容不会执行(<code class=\"language-text\">innerHTML</code>为安全性考虑而设计). 所以经过这样两次渲染之后, 此时的DOM元素是第二次渲染时得到的, 而正常执行过的JS的事件绑定是绑在在第一次渲染出来的DOM元素上, 这样就出现了虽然DOM存在. 但是无法触发该DOM上的事件的情况.</p>\n<p>解决方法:\n将获取到的HTML内容进行匹配, 剔出<code class=\"language-text\">&lt;script&gt;</code>内容, 无论第一次或第二次渲染, 只将<HTML>内容交给<code class=\"language-text\">v-html</code>页面, 然后单独在生命周期<code class=\"language-text\">updated</code>(页面已将HTML内容渲染完成)中将<code class=\"language-text\">&lt;script&gt;</code>创建出来, 添加到页面里自动执行, 实现绑定.\n并在下一次页面重渲染(可能是页面跳转来到)时判断<code class=\"language-text\">&lt;script&gt;</code>是否存在, 如果真则先删去再添加, 这样避免添加多余的<code class=\"language-text\">&lt;script&gt;</code>块.</p>\n<p><strong>而页面为什么会渲染两次呢?</strong></p>\n<p>这是由于Vue SSR在初始页面渲染完成后会有一次<code class=\"language-text\">hydration</code>过程, 在这个过程中会照常执行流程<code class=\"language-text\">mounted</code>等生命周期. 此时会有一个自动判定, 判定是否此时的组件渲染出的内容与SSR渲染得到的内容一致, 如果出现不一致就会单独执行一次额外的CSR, 以达到页面被能正确地渲染. 而因为我们使用了<code class=\"language-text\">v-html</code>, 这个过程只有在CSR时才会被执行, 所以导致了两次渲染出来的内容不一致, 触发了Vue SSR的”补偿渲染机制”, 进而执行了第二次渲染.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/13c8b72d11b89ed2f3a099661be397a6/d9b5d/3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 10.81081081081081%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAcElEQVQI1y2NSw7CMAwFe/+b0ebTpKEraIQoUlddIRALewoOi9GznuxxJ0tFTg5xEc0FGQLSezTmL6n1ZUZDakznRiq8feTZO14uWH62jY77akJbHrPJZIh2oNNsDyz92ETrA6039FrRy4L8+c3sOwfXDJGwdRcFIwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image.png\"\n        title=\"image.png\"\n        src=\"/static/13c8b72d11b89ed2f3a099661be397a6/fcda8/3.png\"\n        srcset=\"/static/13c8b72d11b89ed2f3a099661be397a6/12f09/3.png 148w,\n/static/13c8b72d11b89ed2f3a099661be397a6/e4a3f/3.png 295w,\n/static/13c8b72d11b89ed2f3a099661be397a6/fcda8/3.png 590w,\n/static/13c8b72d11b89ed2f3a099661be397a6/efc66/3.png 885w,\n/static/13c8b72d11b89ed2f3a099661be397a6/c83ae/3.png 1180w,\n/static/13c8b72d11b89ed2f3a099661be397a6/d9b5d/3.png 1224w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n</li>\n<li>\n<p>Cookie传递. 用户的请求会先在服务端被处理, 此时会带客户端的cookie, 但如果在服务端中Egg.js发出异步请求, 这个异步请求中并不带客户端的cookie, 所以如果异步请求需要带携带用户信息的cookie, 此时需要将上下文中的cookie加入Egg的异步请求headers中. 同时返回给客户端时如果涉及到有关cookie的操作也要同步处理一下, 例如用户注销: </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>ctx<span class=\"token punctuation\">.</span><span class=\"token function\">curl</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/logout'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  method<span class=\"token operator\">:</span> <span class=\"token string\">'POST'</span><span class=\"token punctuation\">,</span>\n  dataType<span class=\"token operator\">:</span> <span class=\"token string\">'json'</span><span class=\"token punctuation\">,</span>\n  headers<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 传递 cookie</span>\n    cookie<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>ctx<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">.</span>header<span class=\"token punctuation\">.</span>cookie<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 处理客户端 cookie</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>ctx<span class=\"token punctuation\">.</span>cookies<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'passport_login'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    domain<span class=\"token operator\">:</span> <span class=\"token string\">'.XXX.com'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ol>\n<h3>总结</h3>\n<p>在实现一个展示型web应用, 或者对首屏性能要求较高的场景(例如官网, 技术文档). SSR都是一个很有效且值得投入的技术方案, 一方面享受了框架带来的便利和生态福利, 一方面也兼顾了性能和可扩展性, 对团队的横向探索和技术栈统一也很有好处. 得益于Vue(或React)和Egg.js生态的优势, 丰富的第三方库和繁荣生态支持, 让开发者有更多的选择和优化空间. 同时开发效率也更适合现代web应用的开发节奏, 不需要很高的技术门槛,  就可以上手开发并且支撑大部分的业务场景. 同时Egg.js框架的成熟也让服务端的能力更为强大, 对于安全性和稳定性的设计让我们在处理复杂场景中更加得心应手.</p>\n<p>当然SSR中的坑也不少, 主要是服务端环境下的API规则的不同和一些数据和逻辑处理的约定(例如生命周期, 环境变量, 数据预取), 但只要注意规避这些问题, 在SSR的开发中还是比较顺滑的. 以目前的API设计来说, SPA的代码无法直接放到服务端就能跑(除非实现CSR应用时就考虑了SSR), 其中想改造的话成本可能还不小. 但是一个新应用想要设计为SSR方案, 基本上开发与维护成本和一个SPA应用差不多, 所以在业务开发中是一个较为可靠的技术方案.</p>\n<!-- 目前我们实现的[k2](http://gitlab.alibaba-inc.com/qinshuo.lqs/k2)脚手架已经集成了 Begg + Vue SSR 解决方案, 一键部署, 即开即用, 欢迎大家尝试. -->","frontmatter":{"title":"Vue.js服务端渲染(SSR)不完全指北","date":"September 30, 2019","categories":"弱鸡之路"}}},"pageContext":{"slug":"/Vue.js服务端渲染(SSR)不完全指北/","previous":{"fields":{"slug":"/Gitlab API 指北/"},"frontmatter":{"title":"Gitlab API不完全指北"}},"next":{"fields":{"slug":"/GraphQL与REST相比的优势和短板/"},"frontmatter":{"title":"GraphQL 与 REST 相比的优势和短板"}}}},"staticQueryHashes":["2113486316","63159454"]}