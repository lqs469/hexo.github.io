{"data":{"site":{"siteMetadata":{"title":"Lqs469","author":"lqs469"}},"markdownRemark":{"id":"92cf19cb-b783-575f-9e68-ed2c3fefd4c8","excerpt":"6 月 27 号, TC39 正式完成了 ES2018/ES9 的语言规范  开始进入 ES2019 阶段.\n最终阶段详情:  finished-proposals \n来看看 ES2018 比之前的 ES2017 新增了哪些规范. Object Rest/Spread Properties 对于对象的 Rest…","html":"<p>6 月 27 号, TC39 正式完成了<a href=\"https://tc39.github.io/ecma262/\">ES2018/ES9 的语言规范</a> 开始进入 ES2019 阶段.\n最终阶段详情: <a href=\"https://github.com/tc39/proposals/blob/master/finished-proposals.md\">finished-proposals</a>\n来看看 ES2018 比之前的 ES2017 新增了哪些规范.</p>\n<h2>Object Rest/Spread Properties</h2>\n<p>对于对象的 Rest/Spread, 而之前标准只有数组是支持的. 说出来你可能不信, 这是 ES9 的特性, 我感觉都已经用了很久了…</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>x<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> z<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>x<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>rest<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> obj\n<span class=\"token comment\">// x = 1, rest = { y: 2, z: 3 }</span></code></pre></div>\n<p>很实用的一点比如 React props 可以这样写</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">render</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>props <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props\n\t<span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>props<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Asynchronous Iteration 异步迭代器</h2>\n<p>神奇的异步迭代器, 如果你之前这样写, 循环会依旧保持同步, 而异步独立于循环外, 为什么会导致这个情况想明白这个机制的同学可以去了解一下 js 事件循环.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token keyword\">await</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> line <span class=\"token keyword\">of</span> <span class=\"token function\">readLines</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  \t<span class=\"token comment\">// line by line</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Promise.prototype.finally()</h2>\n<p>又一个以为早就有的特性, 当<code class=\"language-text\">promise</code>结束时稳定被触发(无论<code class=\"language-text\">resolve</code>, <code class=\"language-text\">reject</code>), 几乎是扫尾工作专用方法.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">finally</span><span class=\"token punctuation\">(</span>Fn<span class=\"token punctuation\">)</span></code></pre></div>\n<h2>一系列正则优化</h2>\n<h3><code class=\"language-text\">s</code> 标志和 <code class=\"language-text\">dotAll</code> 模式</h3>\n<p>之前 <code class=\"language-text\">.</code> 用于匹配任何单字符, 但有两个例外:</p>\n<ol>\n<li>\n<p>无法匹配行结束符</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">;</span><span class=\"token regex\">/foo.bar/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo\\nbar'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// → false</span></code></pre></div>\n<p>行终结符:</p>\n</li>\n<li>U+000A LINE FEED (LF) (\\n) - 换行</li>\n<li>U+000D CARRIAGE RETURN (CR) (\\r) - 回车</li>\n<li>U+2028 LINE SEPARATOR - 行分隔符</li>\n<li>U+2029 PARAGRAPH SEPARATOR - 段分隔符\n以及:</li>\n<li>U+000B VERTICAL TAB (\\v)</li>\n<li>U+000C FORM FEED (\\f)</li>\n<li>U+0085 NEXT LINE</li>\n<li>\n<p>多字节字符(非 BMP), 比如 Emoji:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">;</span><span class=\"token regex\">/^.$/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'😀'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// → false</span></code></pre></div>\n<p>曾经可以通过 <code class=\"language-text\">/u</code> 解决:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">;</span><span class=\"token regex\">/^.$/u</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'😀'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// → true</span></code></pre></div>\n</li>\n</ol>\n<p>而在 ES9 中，新增加了一个新的标志 <code class=\"language-text\">s</code>, 让 <code class=\"language-text\">.</code> 可以匹配任意单字符.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> re <span class=\"token operator\">=</span> <span class=\"token operator\">/</span>foo<span class=\"token punctuation\">.</span>bar<span class=\"token operator\">/</span>s <span class=\"token comment\">// Or, `const re = new RegExp('foo.bar', 's');`.</span>\nre<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo\\nbar'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// → true</span>\nre<span class=\"token punctuation\">.</span>dotAll\n<span class=\"token comment\">// → true</span>\nre<span class=\"token punctuation\">.</span>flags\n<span class=\"token comment\">// → 's'</span></code></pre></div>\n<h3>命名捕获组(RegExp Named Capture Groups)</h3>\n<p>以前:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\">/(\\d{4})-(\\d{2})-(\\d{2})/</span>\n<span class=\"token keyword\">const</span> matchers <span class=\"token operator\">=</span> regex<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'2015-01-02'</span><span class=\"token punctuation\">)</span>\nmatchers<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 2015-01-02</span>\nmatchers<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 2015</span>\nmatchers<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 01</span>\nmatchers<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 02</span></code></pre></div>\n<p>现在:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> re <span class=\"token operator\">=</span> <span class=\"token regex\">/(?&lt;year>\\d{4})-(?&lt;month>\\d{2})-(?&lt;day>\\d{2})/u</span>\n<span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> re<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'2015-01-02'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// result.groups.year === '2015';</span>\n<span class=\"token comment\">// result.groups.month === '01';</span>\n<span class=\"token comment\">// result.groups.day === '02';</span>\n\n<span class=\"token comment\">// result[0] === '2015-01-02';</span>\n<span class=\"token comment\">// result[1] === '2015';</span>\n<span class=\"token comment\">// result[2] === '01';</span>\n<span class=\"token comment\">// result[3] === '02';</span></code></pre></div>\n<p>解构一起用:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span>\n  groups<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>one<span class=\"token punctuation\">,</span> two<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token regex\">/^(?&lt;one>.*):(?&lt;two>.*)$/u</span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo:bar'</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`one: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>one<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, two: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>two<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// prints one: foo, two: bar</span></code></pre></div>\n<p>反向引用:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let duplicate = /^(?&lt;half&gt;.*).\\k&lt;half&gt;$/u;\nduplicate.test(&#39;a*b&#39;); // false\nduplicate.test(&#39;a*a&#39;); // true</code></pre></div>\n<p>跟数字捕获组一起使用:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let triplicate = /^(?&lt;part&gt;.*).\\k&lt;part&gt;.\\1$/u;\ntriplicate.test(&#39;a*a*a&#39;); // true\ntriplicate.test(&#39;a*a*b&#39;); // false</code></pre></div>\n<p>替换字符</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let re = /(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})/u;\nlet result = &#39;2015-01-02&#39;.replace(re, &#39;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#39;);\n// result === &#39;02/01/2015&#39;</code></pre></div>\n<h3>反向断言(RegExp Lookbehind Assertions)</h3>\n<p>以往只支持正向断言, 现在支持了反向断言, 语法是 <code class=\"language-text\">(?&lt;=...)</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token regex\">/(?&lt;=\\$)\\d+(\\.\\d*)?/</span></code></pre></div>\n<p>这个例子会匹配 <code class=\"language-text\">&#39;$10.53&#39;</code> 捕获返回 <code class=\"language-text\">&#39;10.53&#39;</code>, 但不会匹配 <code class=\"language-text\">€10.53</code>.</p>\n<h3>Unicode转义(RegExp Unicode Property Escapes)</h3>\n<p>设置<code class=\"language-text\">\\p{Script_Extensions}</code> 或 <code class=\"language-text\">\\P{Script_Extensions}</code>, 使得在 JS 的正则中使用 Unicode 字符, 包括一些奇奇怪怪的字符. 举个例子比如希腊字母:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regexGreekSymbol <span class=\"token operator\">=</span> <span class=\"token regex\">/\\p{Script_Extensions=Greek}/u</span>\nregexGreekSymbol<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'π'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// → true</span></code></pre></div>\n<h2>最后</h2>\n<p>目前大部分特性已经应用于主流浏览器了, 甚至有的早早就有, 也有一些正在实现过程中的. 但如果遇到要解决兼容性的问题还是得老老实实查 MDN, caniuse. 而 Node 端依然落后于标准设计, 这个有历史原因也有稳定性的要求. 新的标准出来的速度快其实大家也不用捉急, 原因在于生产中大部分时候我们其实用不到最新的标准, 或者已有其他的途径或老方法解决掉问题. 写出炫酷的代码不一定是最重要的, 能够解决掉问题才是最重要的. 而新标准更多的意义在于遇到真正刁钻问题的时候能够有解决方法或语言支持, 以及对代码抽象能力的提升, 性能的优化等.</p>","frontmatter":{"title":"JavaScript ES2018/ES9 新增标准","date":"June 29, 2018","categories":"弱鸡之路"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/JavaScript-ES2018-ES9-新增标准/JavaScript-ES2018-ES9-新增标准/","previous":{"fields":{"slug":"/土豆🥔周报生成器/"},"frontmatter":{"title":"土豆🥔周报生成器"}},"next":{"fields":{"slug":"/Backpressure/Backpressure/"},"frontmatter":{"title":"Node.js Streams 中的背压(backpressure)"}}}}